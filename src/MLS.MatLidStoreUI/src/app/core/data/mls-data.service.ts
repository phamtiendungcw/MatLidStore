//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IMatLidStoreAPIServices {
  /**
   * @param body (optional)
   * @return Created
   */
  register(body: RegisterUserCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return OK
   */
  login(body: AuthRequest | undefined): Observable<AuthResponse>;

  /**
   * @return OK
   */
  addressAll(): Observable<AddressDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  addressPOST(body: CreateAddressDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  addressPUT(body: UpdateAddressDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  addressGET(id: number): Observable<AddressDetailsDto>;

  /**
   * @return No Content
   */
  addressDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  articleAll(): Observable<ArticleDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  articlePOST(body: CreateArticleCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  articlePUT(body: UpdateArticleCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  articleGET(id: number): Observable<ArticleDetailsDto>;

  /**
   * @return No Content
   */
  articleDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  authorName(authorName: string): Observable<ArticleDto[]>;

  /**
   * @return OK
   */
  categoryAll(): Observable<CategoryDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  categoryPOST(body: CreateCategoryCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  categoryPUT(body: UpdateCategoryCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  categoryGET(id: number): Observable<CategoryDetailsDto>;

  /**
   * @return No Content
   */
  categoryDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  commentAll(): Observable<CommentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  commentPOST(body: CreateCommentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  commentPUT(body: UpdateCommentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  commentGET(id: number): Observable<CommentDetailsDto>;

  /**
   * @return No Content
   */
  commentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  article(articleId: number): Observable<CommentDto[]>;

  /**
   * @return OK
   */
  discountAll(): Observable<DiscountDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  discountPOST(body: CreateDiscountDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  discountPUT(body: UpdateDiscountDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  discountGET(id: number): Observable<DiscountDetailsDto>;

  /**
   * @return No Content
   */
  discountDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  code(code: string): Observable<DiscountDto>;

  /**
   * @return OK
   */
  notificationAll(): Observable<NotificationDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  notificationPOST(body: CreateNotificationDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  notificationPUT(body: UpdateNotificationDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  notificationGET(id: number): Observable<NotificationDetailsDto>;

  /**
   * @return No Content
   */
  notificationDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  user(userId: number): Observable<NotificationDto[]>;

  /**
   * @return OK
   */
  orderAll(): Observable<OrderDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  orderPOST(body: CreateOrderCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  orderPUT(body: UpdateOrderCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  orderGET(id: number): Observable<OrderDetailsDto>;

  /**
   * @return No Content
   */
  orderDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  orderDetailAll(): Observable<OrderDetailDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  orderDetailPOST(body: CreateOrderDetailCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  orderDetailPUT(body: UpdateOrderDetailCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  orderDetailGET(id: number): Observable<OrderDetailDetailsDto>;

  /**
   * @return No Content
   */
  orderDetailDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  paymentAll(): Observable<PaymentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  paymentPOST(body: CreatePaymentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  paymentPUT(body: UpdatePaymentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  paymentGET(id: number): Observable<PaymentDetailsDto>;

  /**
   * @return No Content
   */
  paymentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productAll(): Observable<ProductDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productPOST(body: CreateProductCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productPUT(body: UpdateProductCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  productGET(id: number): Observable<ProductDetailsDto>;

  /**
   * @return No Content
   */
  productDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productColorAll(): Observable<ProductColorDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productColorPOST(body: CreateProductColorDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productColorPUT(body: UpdateProductColorDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productColorGET(id: number): Observable<ProductColorDetailsDto>;

  /**
   * @return No Content
   */
  productColorDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productImageAll(): Observable<ProductImageDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productImagePOST(body: CreateProductImageDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productImagePUT(body: UpdateProductImageDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productImageGET(id: number): Observable<ProductImageDetailsDto>;

  /**
   * @return No Content
   */
  productImageDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productOptionAll(): Observable<ProductOptionDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productOptionPOST(body: CreateProductOptionDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productOptionPUT(body: UpdateProductOptionDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productOptionGET(id: number): Observable<ProductOptionDetailsDto>;

  /**
   * @return No Content
   */
  productOptionDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productReviewAll(): Observable<ProductReviewDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productReviewPOST(body: CreateProductReviewCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productReviewPUT(body: UpdateProductReviewCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  productReviewGET(id: number): Observable<ProductReviewDetailsDto>;

  /**
   * @return No Content
   */
  productReviewDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productTagAll(): Observable<ProductTagDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productTagPOST(body: CreateProductTagDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productTagPUT(body: UpdateProductTagDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productTagGET(id: number): Observable<ProductTagDetailsDto>;

  /**
   * @return No Content
   */
  productTagDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shipmentAll(): Observable<ShipmentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shipmentPOST(body: CreateShipmentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shipmentPUT(body: UpdateShipmentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shipmentGET(id: number): Observable<ShipmentDetailsDto>;

  /**
   * @return No Content
   */
  shipmentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartAll(): Observable<ShoppingCartDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartPOST(body: CreateShoppingCartCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartPUT(body: UpdateShoppingCartCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartGET(id: number): Observable<ShoppingCartDetailsDto>;

  /**
   * @return No Content
   */
  shoppingCartDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartItemAll(): Observable<ShoppingCartItemDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartItemPOST(body: CreateShoppingCartItemCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartItemPUT(body: UpdateShoppingCartItemCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartItemGET(id: number): Observable<ShoppingCartItemDetailsDto>;

  /**
   * @return No Content
   */
  shoppingCartItemDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  supplierAll(): Observable<SupplierDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  supplierPOST(body: CreateSupplierDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  supplierPUT(body: UpdateSupplierDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  supplierGET(id: number): Observable<SupplierDetailsDto>;

  /**
   * @return No Content
   */
  supplierDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  supplyAll(): Observable<SupplyDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  supplyPOST(body: CreateSupplyDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  supplyPUT(body: UpdateSupplyDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  supplyGET(id: number): Observable<SupplyDetailsDto>;

  /**
   * @return No Content
   */
  supplyDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  tagAll(): Observable<TagDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  tagPOST(body: CreateTagDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  tagPUT(body: UpdateTagDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  tagGET(id: number): Observable<TagDetailsDto>;

  /**
   * @return No Content
   */
  tagDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  userAll(): Observable<UserDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  userPOST(body: CreateUserCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  userPUT(body: UpdateUserCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  userGET(id: number): Observable<UserDetailsDto>;

  /**
   * @return No Content
   */
  userDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  wishListAll(): Observable<WishListDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  wishListPOST(body: CreateWishListCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListPUT(body: UpdateWishListCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  wishListGET(id: number): Observable<WishListDetailsDto>;

  /**
   * @return No Content
   */
  wishListDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  wishListItemAll(): Observable<WishListItemDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  wishListItemPOST(body: CreateWishListItemDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListItemPUT(body: UpdateWishListItemDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  wishListItemGET(id: number): Observable<WishListItemDetailsDto>;

  /**
   * @return No Content
   */
  wishListItemDELETE(id: number): Observable<void>;
}

@Injectable()
export class MatLidStoreAPIServices implements IMatLidStoreAPIServices {
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  private http: HttpClient;
  private readonly baseUrl: string;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @param body (optional)
   * @return Created
   */
  register(body: RegisterUserCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return OK
   */
  login(body: AuthRequest | undefined): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  /**
   * @return OK
   */
  addressAll(): Observable<AddressDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  addressPOST(body: CreateAddressDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  addressPUT(body: UpdateAddressDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  addressGET(id: number): Observable<AddressDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  addressDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  articleAll(): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  articlePOST(body: CreateArticleCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  articlePUT(body: UpdateArticleCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  articleGET(id: number): Observable<ArticleDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  articleDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  authorName(authorName: string): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/AuthorName/{authorName}';
    if (authorName === undefined || authorName === null) throw new Error("The parameter 'authorName' must be defined.");
    url_ = url_.replace('{authorName}', encodeURIComponent('' + authorName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthorName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthorName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  categoryAll(): Observable<CategoryDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  categoryPOST(body: CreateCategoryCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  categoryPUT(body: UpdateCategoryCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  categoryGET(id: number): Observable<CategoryDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  categoryDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  commentAll(): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  commentPOST(body: CreateCommentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  commentPUT(body: UpdateCommentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  commentGET(id: number): Observable<CommentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  commentDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  article(articleId: number): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/article/{articleId}';
    if (articleId === undefined || articleId === null) throw new Error("The parameter 'articleId' must be defined.");
    url_ = url_.replace('{articleId}', encodeURIComponent('' + articleId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticle(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticle(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  discountAll(): Observable<DiscountDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  discountPOST(body: CreateDiscountDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  discountPUT(body: UpdateDiscountDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  discountGET(id: number): Observable<DiscountDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  discountDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  code(code: string): Observable<DiscountDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/code/{code}';
    if (code === undefined || code === null) throw new Error("The parameter 'code' must be defined.");
    url_ = url_.replace('{code}', encodeURIComponent('' + code));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCode(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto>;
        })
      );
  }

  /**
   * @return OK
   */
  notificationAll(): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  notificationPOST(body: CreateNotificationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  notificationPUT(body: UpdateNotificationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  notificationGET(id: number): Observable<NotificationDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  notificationDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  user(userId: number): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/user/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  orderAll(): Observable<OrderDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderPOST(body: CreateOrderCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderPUT(body: UpdateOrderCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderGET(id: number): Observable<OrderDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  orderDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderDetailAll(): Observable<OrderDetailDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderDetailPOST(body: CreateOrderDetailCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderDetailPUT(body: UpdateOrderDetailCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderDetailGET(id: number): Observable<OrderDetailDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  orderDetailDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  paymentAll(): Observable<PaymentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  paymentPOST(body: CreatePaymentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  paymentPUT(body: UpdatePaymentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  paymentGET(id: number): Observable<PaymentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  paymentDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productAll(): Observable<ProductDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productPOST(body: CreateProductCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productPUT(body: UpdateProductCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productGET(id: number): Observable<ProductDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productColorAll(): Observable<ProductColorDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productColorPOST(body: CreateProductColorDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productColorPUT(body: UpdateProductColorDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productColorGET(id: number): Observable<ProductColorDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productColorDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productImageAll(): Observable<ProductImageDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productImagePOST(body: CreateProductImageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productImagePUT(body: UpdateProductImageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productImageGET(id: number): Observable<ProductImageDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productImageDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productOptionAll(): Observable<ProductOptionDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productOptionPOST(body: CreateProductOptionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productOptionPUT(body: UpdateProductOptionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productOptionGET(id: number): Observable<ProductOptionDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productOptionDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productReviewAll(): Observable<ProductReviewDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productReviewPOST(body: CreateProductReviewCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productReviewPUT(body: UpdateProductReviewCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productReviewGET(id: number): Observable<ProductReviewDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productReviewDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productTagAll(): Observable<ProductTagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productTagPOST(body: CreateProductTagDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productTagPUT(body: UpdateProductTagDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productTagGET(id: number): Observable<ProductTagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productTagDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shipmentAll(): Observable<ShipmentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shipmentPOST(body: CreateShipmentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shipmentPUT(body: UpdateShipmentCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shipmentGET(id: number): Observable<ShipmentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shipmentDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartAll(): Observable<ShoppingCartDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartPOST(body: CreateShoppingCartCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartPUT(body: UpdateShoppingCartCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartGET(id: number): Observable<ShoppingCartDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shoppingCartDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartItemAll(): Observable<ShoppingCartItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartItemPOST(body: CreateShoppingCartItemCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartItemPUT(body: UpdateShoppingCartItemCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartItemGET(id: number): Observable<ShoppingCartItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shoppingCartItemDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplierAll(): Observable<SupplierDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplierPOST(body: CreateSupplierDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplierPUT(body: UpdateSupplierDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplierGET(id: number): Observable<SupplierDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  supplierDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplyAll(): Observable<SupplyDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplyPOST(body: CreateSupplyDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplyPUT(body: UpdateSupplyDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplyGET(id: number): Observable<SupplyDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  supplyDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  tagAll(): Observable<TagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  tagPOST(body: CreateTagDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  tagPUT(body: UpdateTagDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  tagGET(id: number): Observable<TagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  tagDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  userAll(): Observable<UserDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  userPOST(body: CreateUserCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  userPUT(body: UpdateUserCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  userGET(id: number): Observable<UserDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  userDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListAll(): Observable<WishListDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListPOST(body: CreateWishListCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListPUT(body: UpdateWishListCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListGET(id: number): Observable<WishListDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  wishListDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListItemAll(): Observable<WishListItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListItemPOST(body: CreateWishListItemDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListItemPUT(body: UpdateWishListItemDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListItemGET(id: number): Observable<WishListItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  wishListItemDELETE(id: number): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processLogin(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException('Unauthorized', status, _responseText, _headers, result401);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressAll(response: HttpResponseBase): Observable<AddressDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(AddressDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processAddressGET(response: HttpResponseBase): Observable<AddressDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AddressDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticleAll(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ArticleDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticlePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticlePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticleGET(response: HttpResponseBase): Observable<ArticleDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ArticleDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticleDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processAuthorName(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ArticleDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryAll(response: HttpResponseBase): Observable<CategoryDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CategoryDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCategoryGET(response: HttpResponseBase): Observable<CategoryDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCommentAll(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CommentDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCommentGET(response: HttpResponseBase): Observable<CommentDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CommentDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticle(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CommentDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountAll(response: HttpResponseBase): Observable<DiscountDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DiscountDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processDiscountGET(response: HttpResponseBase): Observable<DiscountDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DiscountDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCode(response: HttpResponseBase): Observable<DiscountDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DiscountDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationAll(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NotificationDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processNotificationGET(response: HttpResponseBase): Observable<NotificationDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = NotificationDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUser(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NotificationDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderAll(response: HttpResponseBase): Observable<OrderDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OrderDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderGET(response: HttpResponseBase): Observable<OrderDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrderDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderDetailAll(response: HttpResponseBase): Observable<OrderDetailDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OrderDetailDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderDetailGET(response: HttpResponseBase): Observable<OrderDetailDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrderDetailDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processPaymentAll(response: HttpResponseBase): Observable<PaymentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PaymentDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processPaymentGET(response: HttpResponseBase): Observable<PaymentDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductAll(response: HttpResponseBase): Observable<ProductDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductGET(response: HttpResponseBase): Observable<ProductDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductColorAll(response: HttpResponseBase): Observable<ProductColorDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductColorDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductColorGET(response: HttpResponseBase): Observable<ProductColorDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductColorDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductImageAll(response: HttpResponseBase): Observable<ProductImageDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductImageDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImagePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImagePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductImageGET(response: HttpResponseBase): Observable<ProductImageDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductImageDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImageDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductOptionAll(response: HttpResponseBase): Observable<ProductOptionDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductOptionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductOptionGET(response: HttpResponseBase): Observable<ProductOptionDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductOptionDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductReviewAll(response: HttpResponseBase): Observable<ProductReviewDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductReviewDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductReviewGET(response: HttpResponseBase): Observable<ProductReviewDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductReviewDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductTagAll(response: HttpResponseBase): Observable<ProductTagDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductTagDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductTagGET(response: HttpResponseBase): Observable<ProductTagDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductTagDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShipmentAll(response: HttpResponseBase): Observable<ShipmentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShipmentDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShipmentGET(response: HttpResponseBase): Observable<ShipmentDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShipmentDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartAll(response: HttpResponseBase): Observable<ShoppingCartDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShoppingCartDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartGET(response: HttpResponseBase): Observable<ShoppingCartDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShoppingCartDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartItemAll(response: HttpResponseBase): Observable<ShoppingCartItemDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShoppingCartItemDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartItemGET(response: HttpResponseBase): Observable<ShoppingCartItemDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShoppingCartItemDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplierAll(response: HttpResponseBase): Observable<SupplierDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SupplierDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplierGET(response: HttpResponseBase): Observable<SupplierDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplierDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplyAll(response: HttpResponseBase): Observable<SupplyDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SupplyDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplyGET(response: HttpResponseBase): Observable<SupplyDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplyDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processTagAll(response: HttpResponseBase): Observable<TagDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TagDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processTagGET(response: HttpResponseBase): Observable<TagDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TagDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUserAll(response: HttpResponseBase): Observable<UserDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(UserDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUserGET(response: HttpResponseBase): Observable<UserDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListAll(response: HttpResponseBase): Observable<WishListDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WishListDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListGET(response: HttpResponseBase): Observable<WishListDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WishListDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListItemAll(response: HttpResponseBase): Observable<WishListItemDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WishListItemDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListItemGET(response: HttpResponseBase): Observable<WishListItemDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WishListItemDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }
}

export class AddressDetailsDto implements IAddressDetailsDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
  user?: UserDto;

  constructor(data?: IAddressDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddressDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddressDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAddressDetailsDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
  user?: UserDto;
}

export class AddressDto implements IAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;

  constructor(data?: IAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddressDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddressDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export class ArticleDetailsDto implements IArticleDetailsDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
  authorUser?: UserDto;
  comments?: CommentDto[] | undefined;

  constructor(data?: IArticleDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ArticleDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ArticleDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
      this.authorUser = _data['authorUser'] ? UserDto.fromJS(_data['authorUser']) : <any>undefined;
      if (Array.isArray(_data['comments'])) {
        this.comments = [] as any;
        for (let item of _data['comments']) this.comments!.push(CommentDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    data['authorUser'] = this.authorUser ? this.authorUser.toJSON() : <any>undefined;
    if (Array.isArray(this.comments)) {
      data['comments'] = [];
      for (let item of this.comments) data['comments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IArticleDetailsDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
  authorUser?: UserDto;
  comments?: CommentDto[] | undefined;
}

export class ArticleDto implements IArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;

  constructor(data?: IArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ArticleDto {
    data = typeof data === 'object' ? data : {};
    let result = new ArticleDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export class AuthRequest implements IAuthRequest {
  username?: string | undefined;
  password?: string | undefined;

  constructor(data?: IAuthRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AuthRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AuthRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.password = _data['password'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface IAuthRequest {
  username?: string | undefined;
  password?: string | undefined;
}

export class AuthResponse implements IAuthResponse {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  fullName?: string | undefined;
  token?: string | undefined;

  constructor(data?: IAuthResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AuthResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AuthResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.fullName = _data['fullName'];
      this.token = _data['token'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['fullName'] = this.fullName;
    data['token'] = this.token;
    return data;
  }
}

export interface IAuthResponse {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  fullName?: string | undefined;
  token?: string | undefined;
}

export class CategoryDetailsDto implements ICategoryDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  products?: ProductDto[] | undefined;

  constructor(data?: ICategoryDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CategoryDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(ProductDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products) data['products'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  products?: ProductDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: ICategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface ICategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export class CommentDetailsDto implements ICommentDetailsDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
  article?: ArticleDto;
  user?: UserDto;

  constructor(data?: ICommentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CommentDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new CommentDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
      this.article = _data['article'] ? ArticleDto.fromJS(_data['article']) : <any>undefined;
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICommentDetailsDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
  article?: ArticleDto;
  user?: UserDto;
}

export class CommentDto implements ICommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;

  constructor(data?: ICommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CommentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CommentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export class CreateAddressDto implements ICreateAddressDto {
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;

  constructor(data?: ICreateAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateAddressDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAddressDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateAddressDto {
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export class CreateArticleCommand implements ICreateArticleCommand {
  article?: CreateArticleDto;

  constructor(data?: ICreateArticleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateArticleCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateArticleCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.article = _data['article'] ? CreateArticleDto.fromJS(_data['article']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateArticleCommand {
  article?: CreateArticleDto;
}

export class CreateArticleDto implements ICreateArticleDto {
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;

  constructor(data?: ICreateArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateArticleDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateArticleDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateArticleDto {
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
  category?: CreateCategoryDto;

  constructor(data?: ICreateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateCategoryCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCategoryCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.category = _data['category'] ? CreateCategoryDto.fromJS(_data['category']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateCategoryCommand {
  category?: CreateCategoryDto;
}

export class CreateCategoryDto implements ICreateCategoryDto {
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: ICreateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCategoryDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface ICreateCategoryDto {
  name?: string | undefined;
  description?: string | undefined;
}

export class CreateCommentCommand implements ICreateCommentCommand {
  comment?: CreateCommentDto;

  constructor(data?: ICreateCommentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateCommentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCommentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.comment = _data['comment'] ? CreateCommentDto.fromJS(_data['comment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['comment'] = this.comment ? this.comment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateCommentCommand {
  comment?: CreateCommentDto;
}

export class CreateCommentDto implements ICreateCommentDto {
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;

  constructor(data?: ICreateCommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateCommentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCommentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateCommentDto {
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export class CreateDiscountDto implements ICreateDiscountDto {
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: ICreateDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateDiscountDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDiscountDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface ICreateDiscountDto {
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class CreateNotificationDto implements ICreateNotificationDto {
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;

  constructor(data?: ICreateNotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateNotificationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateNotificationDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateNotificationDto {
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export class CreateOrderCommand implements ICreateOrderCommand {
  order?: CreateOrderDto;

  constructor(data?: ICreateOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateOrderCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrderCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.order = _data['order'] ? CreateOrderDto.fromJS(_data['order']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateOrderCommand {
  order?: CreateOrderDto;
}

export class CreateOrderDetailCommand implements ICreateOrderDetailCommand {
  orderDetail?: CreateOrderDetailDto;

  constructor(data?: ICreateOrderDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateOrderDetailCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrderDetailCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.orderDetail = _data['orderDetail'] ? CreateOrderDetailDto.fromJS(_data['orderDetail']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDetail'] = this.orderDetail ? this.orderDetail.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateOrderDetailCommand {
  orderDetail?: CreateOrderDetailDto;
}

export class CreateOrderDetailDto implements ICreateOrderDetailDto {
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;

  constructor(data?: ICreateOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateOrderDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrderDetailDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreateOrderDetailDto {
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export class CreateOrderDto implements ICreateOrderDto {
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  orderDetails?: CreateOrderDetailDto[] | undefined;

  constructor(data?: ICreateOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateOrderDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrderDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(CreateOrderDetailDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateOrderDto {
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  orderDetails?: CreateOrderDetailDto[] | undefined;
}

export class CreatePaymentCommand implements ICreatePaymentCommand {
  payment?: CreatePaymentDto;

  constructor(data?: ICreatePaymentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreatePaymentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePaymentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.payment = _data['payment'] ? CreatePaymentDto.fromJS(_data['payment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payment'] = this.payment ? this.payment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreatePaymentCommand {
  payment?: CreatePaymentDto;
}

export class CreatePaymentDto implements ICreatePaymentDto {
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;

  constructor(data?: ICreatePaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreatePaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePaymentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreatePaymentDto {
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export class CreateProductColorDto implements ICreateProductColorDto {
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;

  constructor(data?: ICreateProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductColorDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductColorDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductColorDto {
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export class CreateProductCommand implements ICreateProductCommand {
  product?: CreateProductDto;

  constructor(data?: ICreateProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data['product'] ? CreateProductDto.fromJS(_data['product']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateProductCommand {
  product?: CreateProductDto;
}

export class CreateProductDto implements ICreateProductDto {
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;

  constructor(data?: ICreateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface ICreateProductDto {
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export class CreateProductImageDto implements ICreateProductImageDto {
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;

  constructor(data?: ICreateProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductImageDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductImageDto {
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export class CreateProductOptionDto implements ICreateProductOptionDto {
  name?: string | undefined;
  value?: number;
  productId?: number;

  constructor(data?: ICreateProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductOptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductOptionDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductOptionDto {
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export class CreateProductReviewCommand implements ICreateProductReviewCommand {
  productReview?: CreateProductReviewDto;

  constructor(data?: ICreateProductReviewCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductReviewCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductReviewCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productReview = _data['productReview']
        ? CreateProductReviewDto.fromJS(_data['productReview'])
        : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productReview'] = this.productReview ? this.productReview.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateProductReviewCommand {
  productReview?: CreateProductReviewDto;
}

export class CreateProductReviewDto implements ICreateProductReviewDto {
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;

  constructor(data?: ICreateProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductReviewDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateProductReviewDto {
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export class CreateProductTagDto implements ICreateProductTagDto {
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;

  constructor(data?: ICreateProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateProductTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductTagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface ICreateProductTagDto {
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export class CreateShipmentCommand implements ICreateShipmentCommand {
  shipment?: CreateShipmentDto;

  constructor(data?: ICreateShipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShipmentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShipmentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shipment = _data['shipment'] ? CreateShipmentDto.fromJS(_data['shipment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipment'] = this.shipment ? this.shipment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShipmentCommand {
  shipment?: CreateShipmentDto;
}

export class CreateShipmentDto implements ICreateShipmentDto {
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;

  constructor(data?: ICreateShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShipmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShipmentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate']
        ? new Date(_data['estimatedDeliveryDate'].toString())
        : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate
      ? this.estimatedDeliveryDate.toISOString()
      : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreateShipmentDto {
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export class CreateShoppingCartCommand implements ICreateShoppingCartCommand {
  shoppingCart?: CreateShoppingCartDto;

  constructor(data?: ICreateShoppingCartCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShoppingCartCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShoppingCartCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shoppingCart = _data['shoppingCart'] ? CreateShoppingCartDto.fromJS(_data['shoppingCart']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShoppingCartCommand {
  shoppingCart?: CreateShoppingCartDto;
}

export class CreateShoppingCartDto implements ICreateShoppingCartDto {
  userId?: number;

  constructor(data?: ICreateShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShoppingCartDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShoppingCartDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateShoppingCartDto {
  userId?: number;
}

export class CreateShoppingCartItemCommand implements ICreateShoppingCartItemCommand {
  shoppingCartItem?: CreateShoppingCartItemDto;

  constructor(data?: ICreateShoppingCartItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShoppingCartItemCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShoppingCartItemCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shoppingCartItem = _data['shoppingCartItem']
        ? CreateShoppingCartItemDto.fromJS(_data['shoppingCartItem'])
        : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCartItem'] = this.shoppingCartItem ? this.shoppingCartItem.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShoppingCartItemCommand {
  shoppingCartItem?: CreateShoppingCartItemDto;
}

export class CreateShoppingCartItemDto implements ICreateShoppingCartItemDto {
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;

  constructor(data?: ICreateShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShoppingCartItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface ICreateShoppingCartItemDto {
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export class CreateSupplierDto implements ICreateSupplierDto {
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: ICreateSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateSupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateSupplierDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface ICreateSupplierDto {
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class CreateSupplyDto implements ICreateSupplyDto {
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ICreateSupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateSupplyDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateSupplyDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ICreateSupplyDto {
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class CreateTagDto implements ICreateTagDto {
  name?: string | undefined;

  constructor(data?: ICreateTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ICreateTagDto {
  name?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
  user?: CreateUserDto;

  constructor(data?: ICreateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data['user'] ? CreateUserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateUserCommand {
  user?: CreateUserDto;
}

export class CreateUserDto implements ICreateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd'] ? new Date(_data['lockoutEnd'].toString()) : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface ICreateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class CreateWishListCommand implements ICreateWishListCommand {
  wishList?: CreateWishListDto;

  constructor(data?: ICreateWishListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateWishListCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateWishListCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.wishList = _data['wishList'] ? CreateWishListDto.fromJS(_data['wishList']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateWishListCommand {
  wishList?: CreateWishListDto;
}

export class CreateWishListDto implements ICreateWishListDto {
  name?: string | undefined;
  userId?: number;

  constructor(data?: ICreateWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateWishListDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateWishListDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateWishListDto {
  name?: string | undefined;
  userId?: number;
}

export class CreateWishListItemDto implements ICreateWishListItemDto {
  productId?: number;
  wishListId?: number;

  constructor(data?: ICreateWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): CreateWishListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateWishListItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface ICreateWishListItemDto {
  productId?: number;
  wishListId?: number;
}

export class DiscountDetailsDto implements IDiscountDetailsDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: IDiscountDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): DiscountDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new DiscountDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IDiscountDetailsDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class DiscountDto implements IDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: IDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): DiscountDto {
    data = typeof data === 'object' ? data : {};
    let result = new DiscountDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class NotificationDetailsDto implements INotificationDetailsDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  user?: UserDto;

  constructor(data?: INotificationDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): NotificationDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface INotificationDetailsDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  user?: UserDto;
}

export class NotificationDto implements INotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;

  constructor(data?: INotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): NotificationDto {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface INotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export class OrderDetailDetailsDto implements IOrderDetailDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  product?: ProductDto;
  order?: OrderDto;

  constructor(data?: IOrderDetailDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): OrderDetailDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrderDetailDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
      this.order = _data['order'] ? OrderDto.fromJS(_data['order']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IOrderDetailDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  product?: ProductDto;
  order?: OrderDto;
}

export class OrderDetailDto implements IOrderDetailDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;

  constructor(data?: IOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): OrderDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrderDetailDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IOrderDetailDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export class OrderDetailsDto implements IOrderDetailsDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  user?: UserDto;
  orderDetails?: OrderDetailDto[] | undefined;

  constructor(data?: IOrderDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): OrderDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrderDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(OrderDetailDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrderDetailsDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  user?: UserDto;
  orderDetails?: OrderDetailDto[] | undefined;
}

export class OrderDto implements IOrderDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;

  constructor(data?: IOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): OrderDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrderDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IOrderDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
}

export class PaymentDetailsDto implements IPaymentDetailsDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
  order?: OrderDto;

  constructor(data?: IPaymentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PaymentDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
      this.order = _data['order'] ? OrderDto.fromJS(_data['order']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPaymentDetailsDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export class PaymentDto implements IPaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;

  constructor(data?: IPaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IPaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export class ProductColorDetailsDto implements IProductColorDetailsDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductColorDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductColorDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductColorDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductColorDetailsDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export class ProductColorDto implements IProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;

  constructor(data?: IProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductColorDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductColorDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export class ProductDetailsDto implements IProductDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
  category?: CategoryDto;
  productOptions?: ProductOptionDto[] | undefined;
  productColors?: ProductColorDto[] | undefined;
  productImages?: ProductImageDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;

  constructor(data?: IProductDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
      this.category = _data['category'] ? CategoryDto.fromJS(_data['category']) : <any>undefined;
      if (Array.isArray(_data['productOptions'])) {
        this.productOptions = [] as any;
        for (let item of _data['productOptions']) this.productOptions!.push(ProductOptionDto.fromJS(item));
      }
      if (Array.isArray(_data['productColors'])) {
        this.productColors = [] as any;
        for (let item of _data['productColors']) this.productColors!.push(ProductColorDto.fromJS(item));
      }
      if (Array.isArray(_data['productImages'])) {
        this.productImages = [] as any;
        for (let item of _data['productImages']) this.productImages!.push(ProductImageDto.fromJS(item));
      }
      if (Array.isArray(_data['productReviews'])) {
        this.productReviews = [] as any;
        for (let item of _data['productReviews']) this.productReviews!.push(ProductReviewDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    if (Array.isArray(this.productOptions)) {
      data['productOptions'] = [];
      for (let item of this.productOptions) data['productOptions'].push(item.toJSON());
    }
    if (Array.isArray(this.productColors)) {
      data['productColors'] = [];
      for (let item of this.productColors) data['productColors'].push(item.toJSON());
    }
    if (Array.isArray(this.productImages)) {
      data['productImages'] = [];
      for (let item of this.productImages) data['productImages'].push(item.toJSON());
    }
    if (Array.isArray(this.productReviews)) {
      data['productReviews'] = [];
      for (let item of this.productReviews) data['productReviews'].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
  category?: CategoryDto;
  productOptions?: ProductOptionDto[] | undefined;
  productColors?: ProductColorDto[] | undefined;
  productImages?: ProductImageDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
}

export class ProductDto implements IProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;

  constructor(data?: IProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface IProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export class ProductImageDetailsDto implements IProductImageDetailsDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductImageDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductImageDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductImageDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductImageDetailsDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export class ProductImageDto implements IProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;

  constructor(data?: IProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductImageDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export class ProductOptionDetailsDto implements IProductOptionDetailsDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductOptionDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductOptionDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductOptionDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductOptionDetailsDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
  product?: ProductDto;
}

export class ProductOptionDto implements IProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;

  constructor(data?: IProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductOptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductOptionDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export class ProductReviewDetailsDto implements IProductReviewDetailsDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
  product?: ProductDto;
  user?: UserDto;

  constructor(data?: IProductReviewDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductReviewDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductReviewDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductReviewDetailsDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
  product?: ProductDto;
  user?: UserDto;
}

export class ProductReviewDto implements IProductReviewDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;

  constructor(data?: IProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductReviewDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IProductReviewDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export class ProductTagDetailsDto implements IProductTagDetailsDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
  product?: ProductDto;
  tag?: TagDto;

  constructor(data?: IProductTagDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductTagDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductTagDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
      this.tag = _data['tag'] ? TagDto.fromJS(_data['tag']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['tag'] = this.tag ? this.tag.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductTagDetailsDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
  product?: ProductDto;
  tag?: TagDto;
}

export class ProductTagDto implements IProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;

  constructor(data?: IProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProductTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductTagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface IProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export class RegisterUserCommand implements IRegisterUserCommand {
  registrationUser?: RegistrationRequest;

  constructor(data?: IRegisterUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): RegisterUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterUserCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.registrationUser = _data['registrationUser']
        ? RegistrationRequest.fromJS(_data['registrationUser'])
        : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['registrationUser'] = this.registrationUser ? this.registrationUser.toJSON() : <any>undefined;
    return data;
  }
}

export interface IRegisterUserCommand {
  registrationUser?: RegistrationRequest;
}

export class RegistrationRequest implements IRegistrationRequest {
  username?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;

  constructor(data?: IRegistrationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): RegistrationRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RegistrationRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.password = _data['password'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['password'] = this.password;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    return data;
  }
}

export interface IRegistrationRequest {
  username?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export class ShipmentDetailsDto implements IShipmentDetailsDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
  order?: OrderDto;

  constructor(data?: IShipmentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShipmentDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShipmentDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate']
        ? new Date(_data['estimatedDeliveryDate'].toString())
        : <any>undefined;
      this.orderId = _data['orderId'];
      this.order = _data['order'] ? OrderDto.fromJS(_data['order']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate
      ? this.estimatedDeliveryDate.toISOString()
      : <any>undefined;
    data['orderId'] = this.orderId;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShipmentDetailsDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export class ShipmentDto implements IShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;

  constructor(data?: IShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShipmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShipmentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate']
        ? new Date(_data['estimatedDeliveryDate'].toString())
        : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate
      ? this.estimatedDeliveryDate.toISOString()
      : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export class ShoppingCartDetailsDto implements IShoppingCartDetailsDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
  user?: UserDto;

  constructor(data?: IShoppingCartDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShoppingCartDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['shoppingCartItems'])) {
        this.shoppingCartItems = [] as any;
        for (let item of _data['shoppingCartItems']) this.shoppingCartItems!.push(ShoppingCartItemDto.fromJS(item));
      }
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    if (Array.isArray(this.shoppingCartItems)) {
      data['shoppingCartItems'] = [];
      for (let item of this.shoppingCartItems) data['shoppingCartItems'].push(item.toJSON());
    }
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShoppingCartDetailsDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
  user?: UserDto;
}

export class ShoppingCartDto implements IShoppingCartDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;

  constructor(data?: IShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShoppingCartDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['shoppingCartItems'])) {
        this.shoppingCartItems = [] as any;
        for (let item of _data['shoppingCartItems']) this.shoppingCartItems!.push(ShoppingCartItemDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    if (Array.isArray(this.shoppingCartItems)) {
      data['shoppingCartItems'] = [];
      for (let item of this.shoppingCartItems) data['shoppingCartItems'].push(item.toJSON());
    }
    return data;
  }
}

export interface IShoppingCartDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
}

export class ShoppingCartItemDetailsDto implements IShoppingCartItemDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
  product?: ProductDto;
  shoppingCart?: ShoppingCartDto;

  constructor(data?: IShoppingCartItemDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShoppingCartItemDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartItemDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
      this.shoppingCart = _data['shoppingCart'] ? ShoppingCartDto.fromJS(_data['shoppingCart']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShoppingCartItemDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
  product?: ProductDto;
  shoppingCart?: ShoppingCartDto;
}

export class ShoppingCartItemDto implements IShoppingCartItemDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;

  constructor(data?: IShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface IShoppingCartItemDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export class SupplierDetailsDto implements ISupplierDetailsDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  products?: ProductDto[] | undefined;

  constructor(data?: ISupplierDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SupplierDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(ProductDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products) data['products'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplierDetailsDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  products?: ProductDto[] | undefined;
}

export class SupplierDto implements ISupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: ISupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface ISupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class SupplyDetailsDto implements ISupplyDetailsDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ISupplyDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SupplyDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ISupplyDetailsDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class SupplyDto implements ISupplyDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ISupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SupplyDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ISupplyDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class TagDetailsDto implements ITagDetailsDto {
  id?: number;
  name?: string | undefined;
  productTags?: ProductTagDto[] | undefined;
  articles?: ArticleDto[] | undefined;

  constructor(data?: ITagDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): TagDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new TagDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['productTags'])) {
        this.productTags = [] as any;
        for (let item of _data['productTags']) this.productTags!.push(ProductTagDto.fromJS(item));
      }
      if (Array.isArray(_data['articles'])) {
        this.articles = [] as any;
        for (let item of _data['articles']) this.articles!.push(ArticleDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.productTags)) {
      data['productTags'] = [];
      for (let item of this.productTags) data['productTags'].push(item.toJSON());
    }
    if (Array.isArray(this.articles)) {
      data['articles'] = [];
      for (let item of this.articles) data['articles'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITagDetailsDto {
  id?: number;
  name?: string | undefined;
  productTags?: ProductTagDto[] | undefined;
  articles?: ArticleDto[] | undefined;
}

export class TagDto implements ITagDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: ITagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): TagDto {
    data = typeof data === 'object' ? data : {};
    let result = new TagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ITagDto {
  id?: number;
  name?: string | undefined;
}

export class UpdateAddressDto implements IUpdateAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateAddressDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateAddressDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number | undefined;
}

export class UpdateArticleCommand implements IUpdateArticleCommand {
  article?: UpdateArticleDto;

  constructor(data?: IUpdateArticleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateArticleCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateArticleCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.article = _data['article'] ? UpdateArticleDto.fromJS(_data['article']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateArticleCommand {
  article?: UpdateArticleDto;
}

export class UpdateArticleDto implements IUpdateArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateArticleDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateArticleDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date | undefined;
  userId?: number | undefined;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
  category?: UpdateCategoryDto;

  constructor(data?: IUpdateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateCategoryCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCategoryCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.category = _data['category'] ? UpdateCategoryDto.fromJS(_data['category']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateCategoryCommand {
  category?: UpdateCategoryDto;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: IUpdateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCategoryDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface IUpdateCategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export class UpdateCommentCommand implements IUpdateCommentCommand {
  comment?: UpdateCommentDto;

  constructor(data?: IUpdateCommentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateCommentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCommentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.comment = _data['comment'] ? UpdateCommentDto.fromJS(_data['comment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['comment'] = this.comment ? this.comment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateCommentCommand {
  comment?: UpdateCommentDto;
}

export class UpdateCommentDto implements IUpdateCommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date | undefined;
  articleId?: number | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateCommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateCommentDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCommentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateCommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date | undefined;
  articleId?: number | undefined;
  userId?: number | undefined;
}

export class UpdateDiscountDto implements IUpdateDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;

  constructor(data?: IUpdateDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateDiscountDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDiscountDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
}

export class UpdateNotificationDto implements IUpdateNotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date | undefined;
  isRead?: boolean | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateNotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateNotificationDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateNotificationDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateNotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date | undefined;
  isRead?: boolean | undefined;
  userId?: number | undefined;
}

export class UpdateOrderCommand implements IUpdateOrderCommand {
  order?: UpdateOrderDto;

  constructor(data?: IUpdateOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateOrderCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrderCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.order = _data['order'] ? UpdateOrderDto.fromJS(_data['order']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateOrderCommand {
  order?: UpdateOrderDto;
}

export class UpdateOrderDetailCommand implements IUpdateOrderDetailCommand {
  orderDetail?: UpdateOrderDetailDto;

  constructor(data?: IUpdateOrderDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateOrderDetailCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrderDetailCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.orderDetail = _data['orderDetail'] ? UpdateOrderDetailDto.fromJS(_data['orderDetail']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDetail'] = this.orderDetail ? this.orderDetail.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateOrderDetailCommand {
  orderDetail?: UpdateOrderDetailDto;
}

export class UpdateOrderDetailDto implements IUpdateOrderDetailDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdateOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateOrderDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrderDetailDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdateOrderDetailDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  orderId?: number | undefined;
}

export class UpdateOrderDto implements IUpdateOrderDto {
  id?: number;
  orderDate?: Date | undefined;
  totalPrice?: number | undefined;
  orderStatus?: string | undefined;
  userId?: number | undefined;
  orderDetails?: UpdateOrderDetailDto[] | undefined;

  constructor(data?: IUpdateOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateOrderDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrderDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(UpdateOrderDetailDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateOrderDto {
  id?: number;
  orderDate?: Date | undefined;
  totalPrice?: number | undefined;
  orderStatus?: string | undefined;
  userId?: number | undefined;
  orderDetails?: UpdateOrderDetailDto[] | undefined;
}

export class UpdatePaymentCommand implements IUpdatePaymentCommand {
  payment?: UpdatePaymentDto;

  constructor(data?: IUpdatePaymentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdatePaymentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePaymentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.payment = _data['payment'] ? UpdatePaymentDto.fromJS(_data['payment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payment'] = this.payment ? this.payment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdatePaymentCommand {
  payment?: UpdatePaymentDto;
}

export class UpdatePaymentDto implements IUpdatePaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number | undefined;
  paymentDate?: Date | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdatePaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdatePaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePaymentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdatePaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number | undefined;
  paymentDate?: Date | undefined;
  orderId?: number | undefined;
}

export class UpdateProductColorDto implements IUpdateProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductColorDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductColorDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number | undefined;
}

export class UpdateProductCommand implements IUpdateProductCommand {
  product?: UpdateProductDto;

  constructor(data?: IUpdateProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data['product'] ? UpdateProductDto.fromJS(_data['product']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateProductCommand {
  product?: UpdateProductDto;
}

export class UpdateProductDto implements IUpdateProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number | undefined;
  categoryId?: number | undefined;

  constructor(data?: IUpdateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface IUpdateProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number | undefined;
  categoryId?: number | undefined;
}

export class UpdateProductImageDto implements IUpdateProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductImageDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number | undefined;
}

export class UpdateProductOptionDto implements IUpdateProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductOptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductOptionDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number | undefined;
  productId?: number | undefined;
}

export class UpdateProductReviewCommand implements IUpdateProductReviewCommand {
  productReview?: UpdateProductReviewDto;

  constructor(data?: IUpdateProductReviewCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductReviewCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductReviewCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.productReview = _data['productReview']
        ? UpdateProductReviewDto.fromJS(_data['productReview'])
        : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productReview'] = this.productReview ? this.productReview.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateProductReviewCommand {
  productReview?: UpdateProductReviewDto;
}

export class UpdateProductReviewDto implements IUpdateProductReviewDto {
  id?: number;
  rating?: number | undefined;
  reviewText?: string | undefined;
  reviewDate?: Date | undefined;
  productId?: number | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductReviewDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateProductReviewDto {
  id?: number;
  rating?: number | undefined;
  reviewText?: string | undefined;
  reviewDate?: Date | undefined;
  productId?: number | undefined;
  userId?: number | undefined;
}

export class UpdateProductTagDto implements IUpdateProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number | undefined;
  tagId?: number | undefined;

  constructor(data?: IUpdateProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateProductTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductTagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface IUpdateProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number | undefined;
  tagId?: number | undefined;
}

export class UpdateShipmentCommand implements IUpdateShipmentCommand {
  shipment?: UpdateShipmentDto;

  constructor(data?: IUpdateShipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShipmentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShipmentCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shipment = _data['shipment'] ? UpdateShipmentDto.fromJS(_data['shipment']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipment'] = this.shipment ? this.shipment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShipmentCommand {
  shipment?: UpdateShipmentDto;
}

export class UpdateShipmentDto implements IUpdateShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdateShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShipmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShipmentDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate']
        ? new Date(_data['estimatedDeliveryDate'].toString())
        : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate
      ? this.estimatedDeliveryDate.toISOString()
      : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdateShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  orderId?: number | undefined;
}

export class UpdateShoppingCartCommand implements IUpdateShoppingCartCommand {
  shoppingCart?: UpdateShoppingCartDto;

  constructor(data?: IUpdateShoppingCartCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShoppingCartCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShoppingCartCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shoppingCart = _data['shoppingCart'] ? UpdateShoppingCartDto.fromJS(_data['shoppingCart']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShoppingCartCommand {
  shoppingCart?: UpdateShoppingCartDto;
}

export class UpdateShoppingCartDto implements IUpdateShoppingCartDto {
  id?: number;
  userId?: number | undefined;

  constructor(data?: IUpdateShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShoppingCartDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShoppingCartDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateShoppingCartDto {
  id?: number;
  userId?: number | undefined;
}

export class UpdateShoppingCartItemCommand implements IUpdateShoppingCartItemCommand {
  shoppingCartItem?: UpdateShoppingCartItemDto;

  constructor(data?: IUpdateShoppingCartItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShoppingCartItemCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShoppingCartItemCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.shoppingCartItem = _data['shoppingCartItem']
        ? UpdateShoppingCartItemDto.fromJS(_data['shoppingCartItem'])
        : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCartItem'] = this.shoppingCartItem ? this.shoppingCartItem.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShoppingCartItemCommand {
  shoppingCartItem?: UpdateShoppingCartItemDto;
}

export class UpdateShoppingCartItemDto implements IUpdateShoppingCartItemDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  shoppingCartId?: number | undefined;

  constructor(data?: IUpdateShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateShoppingCartItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface IUpdateShoppingCartItemDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  shoppingCartId?: number | undefined;
}

export class UpdateSupplierDto implements IUpdateSupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: IUpdateSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateSupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSupplierDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface IUpdateSupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class UpdateSupplyDto implements IUpdateSupplyDto {
  id?: number;
  productId?: number | undefined;
  supplierId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;

  constructor(data?: IUpdateSupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateSupplyDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSupplyDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface IUpdateSupplyDto {
  id?: number;
  productId?: number | undefined;
  supplierId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
}

export class UpdateTagDto implements IUpdateTagDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: IUpdateTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTagDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IUpdateTagDto {
  id?: number;
  name?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
  user?: UpdateUserDto;

  constructor(data?: IUpdateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data['user'] ? UpdateUserDto.fromJS(_data['user']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateUserCommand {
  user?: UpdateUserDto;
}

export class UpdateUserDto implements IUpdateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IUpdateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd'] ? new Date(_data['lockoutEnd'].toString()) : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface IUpdateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class UpdateWishListCommand implements IUpdateWishListCommand {
  wishList?: UpdateWishListDto;

  constructor(data?: IUpdateWishListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateWishListCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateWishListCommand();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.wishList = _data['wishList'] ? UpdateWishListDto.fromJS(_data['wishList']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateWishListCommand {
  wishList?: UpdateWishListDto;
}

export class UpdateWishListDto implements IUpdateWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateWishListDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateWishListDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number | undefined;
}

export class UpdateWishListItemDto implements IUpdateWishListItemDto {
  id?: number;
  productId?: number | undefined;
  wishListId?: number | undefined;

  constructor(data?: IUpdateWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateWishListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateWishListItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface IUpdateWishListItemDto {
  id?: number;
  productId?: number | undefined;
  wishListId?: number | undefined;
}

export class UserDetailsDto implements IUserDetailsDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  token?: string | undefined;
  orders?: OrderDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
  wishLists?: WishListDto[] | undefined;
  comments?: CommentDto[] | undefined;
  notifications?: NotificationDto[] | undefined;

  constructor(data?: IUserDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UserDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
      this.token = _data['token'];
      if (Array.isArray(_data['orders'])) {
        this.orders = [] as any;
        for (let item of _data['orders']) this.orders!.push(OrderDto.fromJS(item));
      }
      if (Array.isArray(_data['productReviews'])) {
        this.productReviews = [] as any;
        for (let item of _data['productReviews']) this.productReviews!.push(ProductReviewDto.fromJS(item));
      }
      if (Array.isArray(_data['wishLists'])) {
        this.wishLists = [] as any;
        for (let item of _data['wishLists']) this.wishLists!.push(WishListDto.fromJS(item));
      }
      if (Array.isArray(_data['comments'])) {
        this.comments = [] as any;
        for (let item of _data['comments']) this.comments!.push(CommentDto.fromJS(item));
      }
      if (Array.isArray(_data['notifications'])) {
        this.notifications = [] as any;
        for (let item of _data['notifications']) this.notifications!.push(NotificationDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    data['token'] = this.token;
    if (Array.isArray(this.orders)) {
      data['orders'] = [];
      for (let item of this.orders) data['orders'].push(item.toJSON());
    }
    if (Array.isArray(this.productReviews)) {
      data['productReviews'] = [];
      for (let item of this.productReviews) data['productReviews'].push(item.toJSON());
    }
    if (Array.isArray(this.wishLists)) {
      data['wishLists'] = [];
      for (let item of this.wishLists) data['wishLists'].push(item.toJSON());
    }
    if (Array.isArray(this.comments)) {
      data['comments'] = [];
      for (let item of this.comments) data['comments'].push(item.toJSON());
    }
    if (Array.isArray(this.notifications)) {
      data['notifications'] = [];
      for (let item of this.notifications) data['notifications'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserDetailsDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  token?: string | undefined;
  orders?: OrderDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
  wishLists?: WishListDto[] | undefined;
  comments?: CommentDto[] | undefined;
  notifications?: NotificationDto[] | undefined;
}

export class UserDto implements IUserDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface IUserDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class WishListDetailsDto implements IWishListDetailsDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
  user?: UserDto;
  wishListItems?: WishListItemDto[] | undefined;

  constructor(data?: IWishListDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): WishListDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishListDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user']) : <any>undefined;
      if (Array.isArray(_data['wishListItems'])) {
        this.wishListItems = [] as any;
        for (let item of _data['wishListItems']) this.wishListItems!.push(WishListItemDto.fromJS(item));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.wishListItems)) {
      data['wishListItems'] = [];
      for (let item of this.wishListItems) data['wishListItems'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWishListDetailsDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
  user?: UserDto;
  wishListItems?: WishListItemDto[] | undefined;
}

export class WishListDto implements IWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number;

  constructor(data?: IWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): WishListDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishListDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
}

export class WishListItemDetailsDto implements IWishListItemDetailsDto {
  id?: number;
  productId?: number;
  wishListId?: number;
  product?: ProductDto;
  wishList?: WishListDto;

  constructor(data?: IWishListItemDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): WishListItemDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishListItemDetailsDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product']) : <any>undefined;
      this.wishList = _data['wishList'] ? WishListDto.fromJS(_data['wishList']) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface IWishListItemDetailsDto {
  id?: number;
  productId?: number;
  wishListId?: number;
  product?: ProductDto;
  wishList?: WishListDto;
}

export class WishListItemDto implements IWishListItemDto {
  id?: number;
  productId?: number;
  wishListId?: number;

  constructor(data?: IWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): WishListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishListItemDto();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface IWishListItemDto {
  id?: number;
  productId?: number;
  wishListId?: number;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;
  protected isApiException = true;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
