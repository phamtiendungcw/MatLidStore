//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { HttpClient, HttpContext, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MatLidStoreServices {
  private http: HttpClient;
  private readonly baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @param body (optional)
   * @return Created
   */
  register(body: RegisterUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  login(body: LoginModel | undefined, httpContext?: HttpContext): Observable<AppUser> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AppUser>;
            }
          } else return _observableThrow(response_) as any as Observable<AppUser>;
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<AppUser> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result201: any = null;
          result201 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as AppUser);
          return _observableOf(result201);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  addressAll(httpContext?: HttpContext): Observable<AddressDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDto[]>;
        })
      );
  }

  protected processAddressAll(response: HttpResponseBase): Observable<AddressDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as AddressDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  addressPOST(body: CreateAddressDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAddressPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  addressPUT(body: UpdateAddressDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAddressPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  addressGET(id: number, httpContext?: HttpContext): Observable<AddressDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDetailsDto>;
        })
      );
  }

  protected processAddressGET(response: HttpResponseBase): Observable<AddressDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as AddressDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  addressDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAddressDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  articleAll(httpContext?: HttpContext): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  protected processArticleAll(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ArticleDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  articlePOST(body: CreateArticleCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processArticlePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  articlePUT(body: UpdateArticleCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processArticlePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  articleGET(id: number, httpContext?: HttpContext): Observable<ArticleDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDetailsDto>;
        })
      );
  }

  protected processArticleGET(response: HttpResponseBase): Observable<ArticleDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ArticleDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  articleDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processArticleDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  authorName(authorName: string, httpContext?: HttpContext): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/AuthorName/{authorName}';
    if (authorName === undefined || authorName === null) throw new Error("The parameter 'authorName' must be defined.");
    url_ = url_.replace('{authorName}', encodeURIComponent('' + authorName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthorName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthorName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  protected processAuthorName(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ArticleDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  categoryAll(httpContext?: HttpContext): Observable<CategoryDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDto[]>;
        })
      );
  }

  protected processCategoryAll(response: HttpResponseBase): Observable<CategoryDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as CategoryDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  categoryPOST(body: CreateCategoryCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCategoryPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  categoryPUT(body: UpdateCategoryCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCategoryPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  categoryGET(id: number, httpContext?: HttpContext): Observable<CategoryDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDetailsDto>;
        })
      );
  }

  protected processCategoryGET(response: HttpResponseBase): Observable<CategoryDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as CategoryDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  categoryDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCategoryDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  commentAll(httpContext?: HttpContext): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  protected processCommentAll(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as CommentDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  commentPOST(body: CreateCommentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCommentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  commentPUT(body: UpdateCommentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCommentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  commentGET(id: number, httpContext?: HttpContext): Observable<CommentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDetailsDto>;
        })
      );
  }

  protected processCommentGET(response: HttpResponseBase): Observable<CommentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as CommentDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  commentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCommentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  article(articleId: number, httpContext?: HttpContext): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/article/{articleId}';
    if (articleId === undefined || articleId === null) throw new Error("The parameter 'articleId' must be defined.");
    url_ = url_.replace('{articleId}', encodeURIComponent('' + articleId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticle(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticle(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  protected processArticle(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as CommentDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  discountAll(httpContext?: HttpContext): Observable<DiscountDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto[]>;
        })
      );
  }

  protected processDiscountAll(response: HttpResponseBase): Observable<DiscountDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as DiscountDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  discountPOST(body: CreateDiscountDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDiscountPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  discountPUT(body: UpdateDiscountDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDiscountPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  discountGET(id: number, httpContext?: HttpContext): Observable<DiscountDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDetailsDto>;
        })
      );
  }

  protected processDiscountGET(response: HttpResponseBase): Observable<DiscountDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as DiscountDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  discountDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDiscountDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  code(code: string, httpContext?: HttpContext): Observable<DiscountDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/code/{code}';
    if (code === undefined || code === null) throw new Error("The parameter 'code' must be defined.");
    url_ = url_.replace('{code}', encodeURIComponent('' + code));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCode(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto>;
        })
      );
  }

  protected processCode(response: HttpResponseBase): Observable<DiscountDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as DiscountDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  notificationAll(httpContext?: HttpContext): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  protected processNotificationAll(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as NotificationDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  notificationPOST(body: CreateNotificationDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processNotificationPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  notificationPUT(body: UpdateNotificationDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processNotificationPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  notificationGET(id: number, httpContext?: HttpContext): Observable<NotificationDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDetailsDto>;
        })
      );
  }

  protected processNotificationGET(response: HttpResponseBase): Observable<NotificationDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as NotificationDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  notificationDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processNotificationDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  user(userId: number, httpContext?: HttpContext): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/user/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  protected processUser(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as NotificationDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  orderAll(httpContext?: HttpContext): Observable<OrderDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDto[]>;
        })
      );
  }

  protected processOrderAll(response: HttpResponseBase): Observable<OrderDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderPOST(body: CreateOrderCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderPUT(body: UpdateOrderCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  orderGET(id: number, httpContext?: HttpContext): Observable<OrderDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        })
      );
  }

  protected processOrderGET(response: HttpResponseBase): Observable<OrderDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  orderDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  orderDetailAll(httpContext?: HttpContext): Observable<OrderDetailDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDto[]>;
        })
      );
  }

  protected processOrderDetailAll(response: HttpResponseBase): Observable<OrderDetailDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderDetailPOST(body: CreateOrderDetailCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderDetailPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderDetailPUT(body: UpdateOrderDetailCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderDetailPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  orderDetailGET(id: number, httpContext?: HttpContext): Observable<OrderDetailDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDetailsDto>;
        })
      );
  }

  protected processOrderDetailGET(response: HttpResponseBase): Observable<OrderDetailDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  orderDetailDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processOrderDetailDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  paymentAll(httpContext?: HttpContext): Observable<PaymentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDto[]>;
        })
      );
  }

  protected processPaymentAll(response: HttpResponseBase): Observable<PaymentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as PaymentDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  paymentPOST(body: CreatePaymentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPaymentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  paymentPUT(body: UpdatePaymentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPaymentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  paymentGET(id: number, httpContext?: HttpContext): Observable<PaymentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDetailsDto>;
        })
      );
  }

  protected processPaymentGET(response: HttpResponseBase): Observable<PaymentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as PaymentDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  paymentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPaymentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productAll(httpContext?: HttpContext): Observable<ProductDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDto[]>;
        })
      );
  }

  protected processProductAll(response: HttpResponseBase): Observable<ProductDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productPOST(body: CreateProductCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productPUT(body: UpdateProductCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productGET(id: number, httpContext?: HttpContext): Observable<ProductDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDetailsDto>;
        })
      );
  }

  protected processProductGET(response: HttpResponseBase): Observable<ProductDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productColorAll(httpContext?: HttpContext): Observable<ProductColorDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDto[]>;
        })
      );
  }

  protected processProductColorAll(response: HttpResponseBase): Observable<ProductColorDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductColorDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productColorPOST(body: CreateProductColorDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductColorPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productColorPUT(body: UpdateProductColorDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductColorPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productColorGET(id: number, httpContext?: HttpContext): Observable<ProductColorDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDetailsDto>;
        })
      );
  }

  protected processProductColorGET(response: HttpResponseBase): Observable<ProductColorDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductColorDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productColorDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductColorDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productImageAll(httpContext?: HttpContext): Observable<ProductImageDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDto[]>;
        })
      );
  }

  protected processProductImageAll(response: HttpResponseBase): Observable<ProductImageDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductImageDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productImagePOST(body: CreateProductImageDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductImagePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productImagePUT(body: UpdateProductImageDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductImagePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productImageGET(id: number, httpContext?: HttpContext): Observable<ProductImageDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDetailsDto>;
        })
      );
  }

  protected processProductImageGET(response: HttpResponseBase): Observable<ProductImageDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductImageDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productImageDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductImageDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productOptionAll(httpContext?: HttpContext): Observable<ProductOptionDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDto[]>;
        })
      );
  }

  protected processProductOptionAll(response: HttpResponseBase): Observable<ProductOptionDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductOptionDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productOptionPOST(body: CreateProductOptionDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductOptionPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productOptionPUT(body: UpdateProductOptionDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductOptionPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productOptionGET(id: number, httpContext?: HttpContext): Observable<ProductOptionDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDetailsDto>;
        })
      );
  }

  protected processProductOptionGET(response: HttpResponseBase): Observable<ProductOptionDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductOptionDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productOptionDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductOptionDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productReviewAll(httpContext?: HttpContext): Observable<ProductReviewDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDto[]>;
        })
      );
  }

  protected processProductReviewAll(response: HttpResponseBase): Observable<ProductReviewDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductReviewDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productReviewPOST(body: CreateProductReviewCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductReviewPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productReviewPUT(body: UpdateProductReviewCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductReviewPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productReviewGET(id: number, httpContext?: HttpContext): Observable<ProductReviewDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDetailsDto>;
        })
      );
  }

  protected processProductReviewGET(response: HttpResponseBase): Observable<ProductReviewDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductReviewDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productReviewDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductReviewDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productTagAll(httpContext?: HttpContext): Observable<ProductTagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDto[]>;
        })
      );
  }

  protected processProductTagAll(response: HttpResponseBase): Observable<ProductTagDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductTagDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productTagPOST(body: CreateProductTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productTagPUT(body: UpdateProductTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  productTagGET(id: number, httpContext?: HttpContext): Observable<ProductTagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDetailsDto>;
        })
      );
  }

  protected processProductTagGET(response: HttpResponseBase): Observable<ProductTagDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProductTagDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  productTagDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processProductTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shipmentAll(httpContext?: HttpContext): Observable<ShipmentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDto[]>;
        })
      );
  }

  protected processShipmentAll(response: HttpResponseBase): Observable<ShipmentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShipmentDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shipmentPOST(body: CreateShipmentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShipmentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shipmentPUT(body: UpdateShipmentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShipmentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shipmentGET(id: number, httpContext?: HttpContext): Observable<ShipmentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDetailsDto>;
        })
      );
  }

  protected processShipmentGET(response: HttpResponseBase): Observable<ShipmentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShipmentDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  shipmentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShipmentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shoppingCartAll(httpContext?: HttpContext): Observable<ShoppingCartDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDto[]>;
        })
      );
  }

  protected processShoppingCartAll(response: HttpResponseBase): Observable<ShoppingCartDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShoppingCartDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartPOST(body: CreateShoppingCartCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartPUT(body: UpdateShoppingCartCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shoppingCartGET(id: number, httpContext?: HttpContext): Observable<ShoppingCartDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDetailsDto>;
        })
      );
  }

  protected processShoppingCartGET(response: HttpResponseBase): Observable<ShoppingCartDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShoppingCartDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  shoppingCartDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shoppingCartItemAll(httpContext?: HttpContext): Observable<ShoppingCartItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDto[]>;
        })
      );
  }

  protected processShoppingCartItemAll(response: HttpResponseBase): Observable<ShoppingCartItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShoppingCartItemDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartItemPOST(body: CreateShoppingCartItemCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartItemPUT(body: UpdateShoppingCartItemCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  shoppingCartItemGET(id: number, httpContext?: HttpContext): Observable<ShoppingCartItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDetailsDto>;
        })
      );
  }

  protected processShoppingCartItemGET(response: HttpResponseBase): Observable<ShoppingCartItemDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ShoppingCartItemDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  shoppingCartItemDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processShoppingCartItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  supplierAll(httpContext?: HttpContext): Observable<SupplierDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDto[]>;
        })
      );
  }

  protected processSupplierAll(response: HttpResponseBase): Observable<SupplierDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as SupplierDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplierPOST(body: CreateSupplierDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplierPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplierPUT(body: UpdateSupplierDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplierPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  supplierGET(id: number, httpContext?: HttpContext): Observable<SupplierDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDetailsDto>;
        })
      );
  }

  protected processSupplierGET(response: HttpResponseBase): Observable<SupplierDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as SupplierDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  supplierDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplierDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  supplyAll(httpContext?: HttpContext): Observable<SupplyDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDto[]>;
        })
      );
  }

  protected processSupplyAll(response: HttpResponseBase): Observable<SupplyDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as SupplyDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplyPOST(body: CreateSupplyDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplyPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplyPUT(body: UpdateSupplyDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplyPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  supplyGET(id: number, httpContext?: HttpContext): Observable<SupplyDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDetailsDto>;
        })
      );
  }

  protected processSupplyGET(response: HttpResponseBase): Observable<SupplyDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as SupplyDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  supplyDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSupplyDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  tagAll(httpContext?: HttpContext): Observable<TagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDto[]>;
        })
      );
  }

  protected processTagAll(response: HttpResponseBase): Observable<TagDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as TagDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  tagPOST(body: CreateTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  tagPUT(body: UpdateTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  tagGET(id: number, httpContext?: HttpContext): Observable<TagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDetailsDto>;
        })
      );
  }

  protected processTagGET(response: HttpResponseBase): Observable<TagDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as TagDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  tagDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  userAll(httpContext?: HttpContext): Observable<UserDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDto[]>;
        })
      );
  }

  protected processUserAll(response: HttpResponseBase): Observable<UserDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as UserDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  userPOST(body: CreateUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUserPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  userPUT(body: UpdateUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUserPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  userGET(id: number, httpContext?: HttpContext): Observable<UserDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDetailsDto>;
        })
      );
  }

  protected processUserGET(response: HttpResponseBase): Observable<UserDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as UserDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  userDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUserDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  wishListAll(httpContext?: HttpContext): Observable<WishListDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDto[]>;
        })
      );
  }

  protected processWishListAll(response: HttpResponseBase): Observable<WishListDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as WishListDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListPOST(body: CreateWishListCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListPUT(body: UpdateWishListCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  wishListGET(id: number, httpContext?: HttpContext): Observable<WishListDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDetailsDto>;
        })
      );
  }

  protected processWishListGET(response: HttpResponseBase): Observable<WishListDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as WishListDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  wishListDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  wishListItemAll(httpContext?: HttpContext): Observable<WishListItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDto[]>;
        })
      );
  }

  protected processWishListItemAll(response: HttpResponseBase): Observable<WishListItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as WishListItemDto[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListItemPOST(body: CreateWishListItemDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListItemPUT(body: UpdateWishListItemDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          result400 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  /**
   * @return OK
   */
  wishListItemGET(id: number, httpContext?: HttpContext): Observable<WishListItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDetailsDto>;
        })
      );
  }

  protected processWishListItemGET(response: HttpResponseBase): Observable<WishListItemDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as WishListItemDetailsDto);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  wishListItemDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processWishListItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          resultdefault = _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }
}

export interface AddressDetailsDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
  user?: UserDto;
}

export interface AddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export interface AppRole {
  id?: number;
  name?: string | undefined;
  normalizedName?: string | undefined;
  concurrencyStamp?: string | undefined;
  userRoles?: AppUserRole[] | undefined;
}

export interface AppUser {
  id?: number;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  passwordSalt?: string | undefined;
  isDeleted?: boolean;
  orders?: Order[] | undefined;
  productReviews?: ProductReview[] | undefined;
  wishLists?: WishList[] | undefined;
  comments?: Comment[] | undefined;
  notifications?: Notification[] | undefined;
  userRoles?: AppUserRole[] | undefined;
}

export interface AppUserRole {
  id?: number;
  name?: string | undefined;
  normalizedName?: string | undefined;
  concurrencyStamp?: string | undefined;
  appUser?: AppUser;
  role?: AppRole;
}

export interface Article {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  authorUserId?: number;
  authorUser?: AppUser;
  comments?: Comment[] | undefined;
}

export interface ArticleDetailsDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
  authorUser?: UserDto;
  comments?: CommentDto[] | undefined;
}

export interface ArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export interface Category {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  name?: string | undefined;
  description?: string | undefined;
  products?: Product[] | undefined;
}

export interface CategoryDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  products?: ProductDto[] | undefined;
}

export interface CategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export interface Comment {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number | undefined;
  article?: Article;
  commenterId?: number;
  commenter?: AppUser;
}

export interface CommentDetailsDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
  article?: ArticleDto;
  user?: UserDto;
}

export interface CommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export interface CreateAddressDto {
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export interface CreateArticleCommand {
  article?: CreateArticleDto;
}

export interface CreateArticleDto {
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export interface CreateCategoryCommand {
  category?: CreateCategoryDto;
}

export interface CreateCategoryDto {
  name?: string | undefined;
  description?: string | undefined;
}

export interface CreateCommentCommand {
  comment?: CreateCommentDto;
}

export interface CreateCommentDto {
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export interface CreateDiscountDto {
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export interface CreateNotificationDto {
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export interface CreateOrderCommand {
  order?: CreateOrderDto;
}

export interface CreateOrderDetailCommand {
  orderDetail?: CreateOrderDetailDto;
}

export interface CreateOrderDetailDto {
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export interface CreateOrderDto {
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  orderDetails?: CreateOrderDetailDto[] | undefined;
}

export interface CreatePaymentCommand {
  payment?: CreatePaymentDto;
}

export interface CreatePaymentDto {
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export interface CreateProductColorDto {
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export interface CreateProductCommand {
  product?: CreateProductDto;
}

export interface CreateProductDto {
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export interface CreateProductImageDto {
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export interface CreateProductOptionDto {
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export interface CreateProductReviewCommand {
  productReview?: CreateProductReviewDto;
}

export interface CreateProductReviewDto {
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export interface CreateProductTagDto {
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export interface CreateShipmentCommand {
  shipment?: CreateShipmentDto;
}

export interface CreateShipmentDto {
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export interface CreateShoppingCartCommand {
  shoppingCart?: CreateShoppingCartDto;
}

export interface CreateShoppingCartDto {
  userId?: number;
}

export interface CreateShoppingCartItemCommand {
  shoppingCartItem?: CreateShoppingCartItemDto;
}

export interface CreateShoppingCartItemDto {
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export interface CreateSupplierDto {
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export interface CreateSupplyDto {
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export interface CreateTagDto {
  name?: string | undefined;
}

export interface CreateUserCommand {
  user?: CreateUserDto;
}

export interface CreateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export interface CreateWishListCommand {
  wishList?: CreateWishListDto;
}

export interface CreateWishListDto {
  name?: string | undefined;
  userId?: number;
}

export interface CreateWishListItemDto {
  productId?: number;
  wishListId?: number;
}

export interface DiscountDetailsDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export interface DiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export interface LoginModel {
  username?: string | undefined;
  password?: string | undefined;
}

export interface Notification {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  appUser?: AppUser;
}

export interface NotificationDetailsDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  user?: UserDto;
}

export interface NotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export interface Order {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  appUser?: AppUser;
  orderDetails?: OrderDetail[] | undefined;
}

export interface OrderDetail {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  productId?: number;
  product?: Product;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  order?: Order;
}

export interface OrderDetailDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  product?: ProductDto;
  order?: OrderDto;
}

export interface OrderDetailDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export interface OrderDetailsDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  user?: UserDto;
  orderDetails?: OrderDetailDto[] | undefined;
}

export interface OrderDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
}

export interface PaymentDetailsDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export interface PaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export interface ProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export interface Product {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  stockQuantity?: number;
  sku?: string | undefined;
  categoryId?: number;
  category?: Category;
  productOptions?: ProductOption[] | undefined;
  productColors?: ProductColor[] | undefined;
  productImages?: ProductImage[] | undefined;
  productReviews?: ProductReview[] | undefined;
  orderDetails?: OrderDetail[] | undefined;
}

export interface ProductColor {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: Product;
}

export interface ProductColorDetailsDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export interface ProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export interface ProductDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
  category?: CategoryDto;
  productOptions?: ProductOptionDto[] | undefined;
  productColors?: ProductColorDto[] | undefined;
  productImages?: ProductImageDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
}

export interface ProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export interface ProductImage {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: Product;
}

export interface ProductImageDetailsDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export interface ProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export interface ProductOption {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  name?: string | undefined;
  value?: string | undefined;
  productId?: number;
  product?: Product;
}

export interface ProductOptionDetailsDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
  product?: ProductDto;
}

export interface ProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export interface ProductReview {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  product?: Product;
  userId?: number;
  appUser?: AppUser;
}

export interface ProductReviewDetailsDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
  product?: ProductDto;
  user?: UserDto;
}

export interface ProductReviewDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export interface ProductTagDetailsDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
  product?: ProductDto;
  tag?: TagDto;
}

export interface ProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export interface RegisterModel {
  username?: string | undefined;
  password?: string | undefined;
  passwordHash?: string | undefined;
  passwordSalt?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export interface RegisterUserCommand {
  registerUser?: RegisterModel;
}

export interface ShipmentDetailsDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export interface ShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export interface ShoppingCartDetailsDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
  user?: UserDto;
}

export interface ShoppingCartDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
}

export interface ShoppingCartItemDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
  product?: ProductDto;
  shoppingCart?: ShoppingCartDto;
}

export interface ShoppingCartItemDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export interface SupplierDetailsDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  products?: ProductDto[] | undefined;
}

export interface SupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export interface SupplyDetailsDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export interface SupplyDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export interface TagDetailsDto {
  id?: number;
  name?: string | undefined;
  productTags?: ProductTagDto[] | undefined;
  articles?: ArticleDto[] | undefined;
}

export interface TagDto {
  id?: number;
  name?: string | undefined;
}

export interface UpdateAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number | undefined;
}

export interface UpdateArticleCommand {
  article?: UpdateArticleDto;
}

export interface UpdateArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date | undefined;
  userId?: number | undefined;
}

export interface UpdateCategoryCommand {
  category?: UpdateCategoryDto;
}

export interface UpdateCategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export interface UpdateCommentCommand {
  comment?: UpdateCommentDto;
}

export interface UpdateCommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date | undefined;
  articleId?: number | undefined;
  userId?: number | undefined;
}

export interface UpdateDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
}

export interface UpdateNotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date | undefined;
  isRead?: boolean | undefined;
  userId?: number | undefined;
}

export interface UpdateOrderCommand {
  order?: UpdateOrderDto;
}

export interface UpdateOrderDetailCommand {
  orderDetail?: UpdateOrderDetailDto;
}

export interface UpdateOrderDetailDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  orderId?: number | undefined;
}

export interface UpdateOrderDto {
  id?: number;
  orderDate?: Date | undefined;
  totalPrice?: number | undefined;
  orderStatus?: string | undefined;
  userId?: number | undefined;
  orderDetails?: UpdateOrderDetailDto[] | undefined;
}

export interface UpdatePaymentCommand {
  payment?: UpdatePaymentDto;
}

export interface UpdatePaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number | undefined;
  paymentDate?: Date | undefined;
  orderId?: number | undefined;
}

export interface UpdateProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number | undefined;
}

export interface UpdateProductCommand {
  product?: UpdateProductDto;
}

export interface UpdateProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number | undefined;
  categoryId?: number | undefined;
}

export interface UpdateProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number | undefined;
}

export interface UpdateProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number | undefined;
  productId?: number | undefined;
}

export interface UpdateProductReviewCommand {
  productReview?: UpdateProductReviewDto;
}

export interface UpdateProductReviewDto {
  id?: number;
  rating?: number | undefined;
  reviewText?: string | undefined;
  reviewDate?: Date | undefined;
  productId?: number | undefined;
  userId?: number | undefined;
}

export interface UpdateProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number | undefined;
  tagId?: number | undefined;
}

export interface UpdateShipmentCommand {
  shipment?: UpdateShipmentDto;
}

export interface UpdateShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  orderId?: number | undefined;
}

export interface UpdateShoppingCartCommand {
  shoppingCart?: UpdateShoppingCartDto;
}

export interface UpdateShoppingCartDto {
  id?: number;
  userId?: number | undefined;
}

export interface UpdateShoppingCartItemCommand {
  shoppingCartItem?: UpdateShoppingCartItemDto;
}

export interface UpdateShoppingCartItemDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  shoppingCartId?: number | undefined;
}

export interface UpdateSupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export interface UpdateSupplyDto {
  id?: number;
  productId?: number | undefined;
  supplierId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
}

export interface UpdateTagDto {
  id?: number;
  name?: string | undefined;
}

export interface UpdateUserCommand {
  user?: UpdateUserDto;
}

export interface UpdateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export interface UpdateWishListCommand {
  wishList?: UpdateWishListDto;
}

export interface UpdateWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number | undefined;
}

export interface UpdateWishListItemDto {
  id?: number;
  productId?: number | undefined;
  wishListId?: number | undefined;
}

export interface UserDetailsDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  token?: string | undefined;
  orders?: OrderDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
  wishLists?: WishListDto[] | undefined;
  comments?: CommentDto[] | undefined;
  notifications?: NotificationDto[] | undefined;
}

export interface UserDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export interface WishList {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  name?: string | undefined;
  userId?: number;
  appUser?: AppUser;
  wishListItems?: WishListItem[] | undefined;
}

export interface WishListDetailsDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
  user?: UserDto;
  wishListItems?: WishListItemDto[] | undefined;
}

export interface WishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
}

export interface WishListItem {
  id?: number;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  isDeleted?: boolean;
  productId?: number;
  product?: Product;
  wishListId?: number;
  wishList?: WishList;
}

export interface WishListItemDetailsDto {
  id?: number;
  productId?: number;
  wishListId?: number;
  product?: ProductDto;
  wishList?: WishListDto;
}

export interface WishListItemDto {
  id?: number;
  productId?: number;
  wishListId?: number;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: {
    [key: string]: any;
  },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
