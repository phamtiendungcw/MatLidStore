//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { HttpClient, HttpContext, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IMatLidStoreServices {
  /**
   * @param body (optional)
   * @return OK
   */
  register(body: RegisterUserCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return OK
   */
  login(body: LoginModel | undefined): Observable<UserDetailsDto>;

  /**
   * @return OK
   */
  addressAll(): Observable<AddressDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  addressPOST(body: CreateAddressDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  addressPUT(body: UpdateAddressDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  addressGET(id: number): Observable<AddressDetailsDto>;

  /**
   * @return No Content
   */
  addressDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  articleAll(): Observable<ArticleDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  articlePOST(body: CreateArticleCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  articlePUT(body: UpdateArticleCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  articleGET(id: number): Observable<ArticleDetailsDto>;

  /**
   * @return No Content
   */
  articleDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  authorName(authorName: string): Observable<ArticleDto[]>;

  /**
   * @return OK
   */
  categoryAll(): Observable<CategoryDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  categoryPOST(body: CreateCategoryCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  categoryPUT(body: UpdateCategoryCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  categoryGET(id: number): Observable<CategoryDetailsDto>;

  /**
   * @return No Content
   */
  categoryDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  commentAll(): Observable<CommentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  commentPOST(body: CreateCommentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  commentPUT(body: UpdateCommentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  commentGET(id: number): Observable<CommentDetailsDto>;

  /**
   * @return No Content
   */
  commentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  article(articleId: number): Observable<CommentDto[]>;

  /**
   * @return OK
   */
  discountAll(): Observable<DiscountDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  discountPOST(body: CreateDiscountDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  discountPUT(body: UpdateDiscountDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  discountGET(id: number): Observable<DiscountDetailsDto>;

  /**
   * @return No Content
   */
  discountDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  code(code: string): Observable<DiscountDto>;

  /**
   * @return OK
   */
  notificationAll(): Observable<NotificationDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  notificationPOST(body: CreateNotificationDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  notificationPUT(body: UpdateNotificationDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  notificationGET(id: number): Observable<NotificationDetailsDto>;

  /**
   * @return No Content
   */
  notificationDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  user(userId: number): Observable<NotificationDto[]>;

  /**
   * @return OK
   */
  orderAll(): Observable<OrderDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  orderPOST(body: CreateOrderCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  orderPUT(body: UpdateOrderCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  orderGET(id: number): Observable<OrderDetailsDto>;

  /**
   * @return No Content
   */
  orderDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  orderDetailAll(): Observable<OrderDetailDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  orderDetailPOST(body: CreateOrderDetailCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  orderDetailPUT(body: UpdateOrderDetailCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  orderDetailGET(id: number): Observable<OrderDetailDetailsDto>;

  /**
   * @return No Content
   */
  orderDetailDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  paymentAll(): Observable<PaymentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  paymentPOST(body: CreatePaymentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  paymentPUT(body: UpdatePaymentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  paymentGET(id: number): Observable<PaymentDetailsDto>;

  /**
   * @return No Content
   */
  paymentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productAll(): Observable<ProductDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productPOST(body: CreateProductCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productPUT(body: UpdateProductCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  productGET(id: number): Observable<ProductDetailsDto>;

  /**
   * @return No Content
   */
  productDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productColorAll(): Observable<ProductColorDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productColorPOST(body: CreateProductColorDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productColorPUT(body: UpdateProductColorDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productColorGET(id: number): Observable<ProductColorDetailsDto>;

  /**
   * @return No Content
   */
  productColorDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productImageAll(): Observable<ProductImageDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productImagePOST(body: CreateProductImageDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productImagePUT(body: UpdateProductImageDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productImageGET(id: number): Observable<ProductImageDetailsDto>;

  /**
   * @return No Content
   */
  productImageDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productOptionAll(): Observable<ProductOptionDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productOptionPOST(body: CreateProductOptionDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productOptionPUT(body: UpdateProductOptionDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productOptionGET(id: number): Observable<ProductOptionDetailsDto>;

  /**
   * @return No Content
   */
  productOptionDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productReviewAll(): Observable<ProductReviewDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productReviewPOST(body: CreateProductReviewCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productReviewPUT(body: UpdateProductReviewCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  productReviewGET(id: number): Observable<ProductReviewDetailsDto>;

  /**
   * @return No Content
   */
  productReviewDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  productTagAll(): Observable<ProductTagDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  productTagPOST(body: CreateProductTagDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  productTagPUT(body: UpdateProductTagDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  productTagGET(id: number): Observable<ProductTagDetailsDto>;

  /**
   * @return No Content
   */
  productTagDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shipmentAll(): Observable<ShipmentDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shipmentPOST(body: CreateShipmentCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shipmentPUT(body: UpdateShipmentCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shipmentGET(id: number): Observable<ShipmentDetailsDto>;

  /**
   * @return No Content
   */
  shipmentDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartAll(): Observable<ShoppingCartDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartPOST(body: CreateShoppingCartCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartPUT(body: UpdateShoppingCartCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartGET(id: number): Observable<ShoppingCartDetailsDto>;

  /**
   * @return No Content
   */
  shoppingCartDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartItemAll(): Observable<ShoppingCartItemDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartItemPOST(body: CreateShoppingCartItemCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartItemPUT(body: UpdateShoppingCartItemCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  shoppingCartItemGET(id: number): Observable<ShoppingCartItemDetailsDto>;

  /**
   * @return No Content
   */
  shoppingCartItemDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  supplierAll(): Observable<SupplierDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  supplierPOST(body: CreateSupplierDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  supplierPUT(body: UpdateSupplierDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  supplierGET(id: number): Observable<SupplierDetailsDto>;

  /**
   * @return No Content
   */
  supplierDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  supplyAll(): Observable<SupplyDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  supplyPOST(body: CreateSupplyDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  supplyPUT(body: UpdateSupplyDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  supplyGET(id: number): Observable<SupplyDetailsDto>;

  /**
   * @return No Content
   */
  supplyDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  tagAll(): Observable<TagDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  tagPOST(body: CreateTagDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  tagPUT(body: UpdateTagDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  tagGET(id: number): Observable<TagDetailsDto>;

  /**
   * @return No Content
   */
  tagDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  userAll(): Observable<UserDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  userPOST(body: CreateUserCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  userPUT(body: UpdateUserCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  userGET(id: number): Observable<UserDetailsDto>;

  /**
   * @return No Content
   */
  userDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  wishListAll(): Observable<WishListDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  wishListPOST(body: CreateWishListCommand | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListPUT(body: UpdateWishListCommand | undefined): Observable<void>;

  /**
   * @return OK
   */
  wishListGET(id: number): Observable<WishListDetailsDto>;

  /**
   * @return No Content
   */
  wishListDELETE(id: number): Observable<void>;

  /**
   * @return OK
   */
  wishListItemAll(): Observable<WishListItemDto[]>;

  /**
   * @param body (optional)
   * @return Created
   */
  wishListItemPOST(body: CreateWishListItemDto | undefined): Observable<void>;

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListItemPUT(body: UpdateWishListItemDto | undefined): Observable<void>;

  /**
   * @return OK
   */
  wishListItemGET(id: number): Observable<WishListItemDetailsDto>;

  /**
   * @return No Content
   */
  wishListItemDELETE(id: number): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class MatLidStoreServices implements IMatLidStoreServices {
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  private http: HttpClient;
  private readonly baseUrl: string;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @param body (optional)
   * @return OK
   */
  register(body: RegisterUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return OK
   */
  login(body: LoginModel | undefined, httpContext?: HttpContext): Observable<UserDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Account/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDetailsDto>;
        })
      );
  }

  /**
   * @return OK
   */
  addressAll(httpContext?: HttpContext): Observable<AddressDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  addressPOST(body: CreateAddressDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  addressPUT(body: UpdateAddressDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  addressGET(id: number, httpContext?: HttpContext): Observable<AddressDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AddressDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<AddressDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  addressDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Address/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddressDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddressDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  articleAll(httpContext?: HttpContext): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  articlePOST(body: CreateArticleCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  articlePUT(body: UpdateArticleCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  articleGET(id: number, httpContext?: HttpContext): Observable<ArticleDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  articleDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticleDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticleDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  authorName(authorName: string, httpContext?: HttpContext): Observable<ArticleDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Article/AuthorName/{authorName}';
    if (authorName === undefined || authorName === null) throw new Error("The parameter 'authorName' must be defined.");
    url_ = url_.replace('{authorName}', encodeURIComponent('' + authorName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthorName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthorName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ArticleDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ArticleDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  categoryAll(httpContext?: HttpContext): Observable<CategoryDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  categoryPOST(body: CreateCategoryCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  categoryPUT(body: UpdateCategoryCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  categoryGET(id: number, httpContext?: HttpContext): Observable<CategoryDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CategoryDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  categoryDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Category/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategoryDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategoryDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  commentAll(httpContext?: HttpContext): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  commentPOST(body: CreateCommentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  commentPUT(body: UpdateCommentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  commentGET(id: number, httpContext?: HttpContext): Observable<CommentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  commentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCommentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCommentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  article(articleId: number, httpContext?: HttpContext): Observable<CommentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Comment/article/{articleId}';
    if (articleId === undefined || articleId === null) throw new Error("The parameter 'articleId' must be defined.");
    url_ = url_.replace('{articleId}', encodeURIComponent('' + articleId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticle(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticle(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CommentDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  discountAll(httpContext?: HttpContext): Observable<DiscountDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  discountPOST(body: CreateDiscountDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  discountPUT(body: UpdateDiscountDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  discountGET(id: number, httpContext?: HttpContext): Observable<DiscountDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  discountDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDiscountDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDiscountDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  code(code: string, httpContext?: HttpContext): Observable<DiscountDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Discount/code/{code}';
    if (code === undefined || code === null) throw new Error("The parameter 'code' must be defined.");
    url_ = url_.replace('{code}', encodeURIComponent('' + code));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCode(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DiscountDto>;
            }
          } else return _observableThrow(response_) as any as Observable<DiscountDto>;
        })
      );
  }

  /**
   * @return OK
   */
  notificationAll(httpContext?: HttpContext): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  notificationPOST(body: CreateNotificationDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  notificationPUT(body: UpdateNotificationDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  notificationGET(id: number, httpContext?: HttpContext): Observable<NotificationDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  notificationDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNotificationDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNotificationDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  user(userId: number, httpContext?: HttpContext): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Notification/user/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NotificationDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        })
      );
  }

  /**
   * @return OK
   */
  orderAll(httpContext?: HttpContext): Observable<OrderDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderPOST(body: CreateOrderCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderPUT(body: UpdateOrderCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderGET(id: number, httpContext?: HttpContext): Observable<OrderDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  orderDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Order/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderDetailAll(httpContext?: HttpContext): Observable<OrderDetailDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  orderDetailPOST(body: CreateOrderDetailCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  orderDetailPUT(body: UpdateOrderDetailCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  orderDetailGET(id: number, httpContext?: HttpContext): Observable<OrderDetailDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDetailDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<OrderDetailDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  orderDetailDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/OrderDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetailDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetailDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  paymentAll(httpContext?: HttpContext): Observable<PaymentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  paymentPOST(body: CreatePaymentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  paymentPUT(body: UpdatePaymentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  paymentGET(id: number, httpContext?: HttpContext): Observable<PaymentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<PaymentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  paymentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Payment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productAll(httpContext?: HttpContext): Observable<ProductDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productPOST(body: CreateProductCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productPUT(body: UpdateProductCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productGET(id: number, httpContext?: HttpContext): Observable<ProductDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Product/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productColorAll(httpContext?: HttpContext): Observable<ProductColorDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productColorPOST(body: CreateProductColorDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productColorPUT(body: UpdateProductColorDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productColorGET(id: number, httpContext?: HttpContext): Observable<ProductColorDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductColorDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductColorDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productColorDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductColor/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductColorDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductColorDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productImageAll(httpContext?: HttpContext): Observable<ProductImageDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productImagePOST(body: CreateProductImageDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productImagePUT(body: UpdateProductImageDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImagePUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImagePUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productImageGET(id: number, httpContext?: HttpContext): Observable<ProductImageDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductImageDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductImageDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productImageDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductImage/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductImageDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductImageDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productOptionAll(httpContext?: HttpContext): Observable<ProductOptionDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productOptionPOST(body: CreateProductOptionDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productOptionPUT(body: UpdateProductOptionDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productOptionGET(id: number, httpContext?: HttpContext): Observable<ProductOptionDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductOptionDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductOptionDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productOptionDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductOption/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductOptionDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductOptionDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productReviewAll(httpContext?: HttpContext): Observable<ProductReviewDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productReviewPOST(body: CreateProductReviewCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productReviewPUT(body: UpdateProductReviewCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productReviewGET(id: number, httpContext?: HttpContext): Observable<ProductReviewDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductReviewDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductReviewDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productReviewDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductReview/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductReviewDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductReviewDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productTagAll(httpContext?: HttpContext): Observable<ProductTagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  productTagPOST(body: CreateProductTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  productTagPUT(body: UpdateProductTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  productTagGET(id: number, httpContext?: HttpContext): Observable<ProductTagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductTagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ProductTagDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  productTagDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ProductTag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProductTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProductTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shipmentAll(httpContext?: HttpContext): Observable<ShipmentDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shipmentPOST(body: CreateShipmentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shipmentPUT(body: UpdateShipmentCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shipmentGET(id: number, httpContext?: HttpContext): Observable<ShipmentDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShipmentDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShipmentDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shipmentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Shipment/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShipmentDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShipmentDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartAll(httpContext?: HttpContext): Observable<ShoppingCartDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartPOST(body: CreateShoppingCartCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartPUT(body: UpdateShoppingCartCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartGET(id: number, httpContext?: HttpContext): Observable<ShoppingCartDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shoppingCartDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCart/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartItemAll(httpContext?: HttpContext): Observable<ShoppingCartItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  shoppingCartItemPOST(body: CreateShoppingCartItemCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  shoppingCartItemPUT(body: UpdateShoppingCartItemCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  shoppingCartItemGET(id: number, httpContext?: HttpContext): Observable<ShoppingCartItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ShoppingCartItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ShoppingCartItemDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  shoppingCartItemDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/ShoppingCartItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processShoppingCartItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processShoppingCartItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplierAll(httpContext?: HttpContext): Observable<SupplierDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplierPOST(body: CreateSupplierDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplierPUT(body: UpdateSupplierDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplierGET(id: number, httpContext?: HttpContext): Observable<SupplierDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplierDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  supplierDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supplier/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplierDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplierDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplyAll(httpContext?: HttpContext): Observable<SupplyDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  supplyPOST(body: CreateSupplyDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  supplyPUT(body: UpdateSupplyDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  supplyGET(id: number, httpContext?: HttpContext): Observable<SupplyDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<SupplyDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  supplyDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Supply/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSupplyDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSupplyDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  tagAll(httpContext?: HttpContext): Observable<TagDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  tagPOST(body: CreateTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  tagPUT(body: UpdateTagDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  tagGET(id: number, httpContext?: HttpContext): Observable<TagDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TagDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<TagDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  tagDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/Tag/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTagDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTagDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  userAll(httpContext?: HttpContext): Observable<UserDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  userPOST(body: CreateUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  userPUT(body: UpdateUserCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  userGET(id: number, httpContext?: HttpContext): Observable<UserDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<UserDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  userDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/User/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListAll(httpContext?: HttpContext): Observable<WishListDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListPOST(body: CreateWishListCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListPUT(body: UpdateWishListCommand | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListGET(id: number, httpContext?: HttpContext): Observable<WishListDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  wishListDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishList/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListItemAll(httpContext?: HttpContext): Observable<WishListItemDto[]> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDto[]>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDto[]>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return Created
   */
  wishListItemPOST(body: CreateWishListItemDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  wishListItemPUT(body: UpdateWishListItemDto | undefined, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  /**
   * @return OK
   */
  wishListItemGET(id: number, httpContext?: HttpContext): Observable<WishListItemDetailsDto> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishListItemDetailsDto>;
            }
          } else return _observableThrow(response_) as any as Observable<WishListItemDetailsDto>;
        })
      );
  }

  /**
   * @return No Content
   */
  wishListItemDELETE(id: number, httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + '/MatLidStoreApi/WishListItem/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWishListItemDELETE(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWishListItemDELETE(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processLogin(response: HttpResponseBase): Observable<UserDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = UserDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result201 = UserDetailsDto.fromJS(resultData201, _mappings);
          return _observableOf(result201);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressAll(response: HttpResponseBase): Observable<AddressDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(AddressDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processAddressGET(response: HttpResponseBase): Observable<AddressDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = AddressDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processAddressDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticleAll(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ArticleDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticlePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticlePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticleGET(response: HttpResponseBase): Observable<ArticleDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ArticleDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processArticleDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processAuthorName(response: HttpResponseBase): Observable<ArticleDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ArticleDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryAll(response: HttpResponseBase): Observable<CategoryDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CategoryDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCategoryGET(response: HttpResponseBase): Observable<CategoryDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = CategoryDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCategoryDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCommentAll(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CommentDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCommentGET(response: HttpResponseBase): Observable<CommentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = CommentDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processCommentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processArticle(response: HttpResponseBase): Observable<CommentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CommentDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountAll(response: HttpResponseBase): Observable<DiscountDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DiscountDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processDiscountGET(response: HttpResponseBase): Observable<DiscountDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = DiscountDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processDiscountDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processCode(response: HttpResponseBase): Observable<DiscountDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = DiscountDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationAll(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NotificationDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processNotificationGET(response: HttpResponseBase): Observable<NotificationDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = NotificationDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processNotificationDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUser(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NotificationDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderAll(response: HttpResponseBase): Observable<OrderDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OrderDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderGET(response: HttpResponseBase): Observable<OrderDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = OrderDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderDetailAll(response: HttpResponseBase): Observable<OrderDetailDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OrderDetailDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processOrderDetailGET(response: HttpResponseBase): Observable<OrderDetailDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = OrderDetailDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processOrderDetailDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processPaymentAll(response: HttpResponseBase): Observable<PaymentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PaymentDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processPaymentGET(response: HttpResponseBase): Observable<PaymentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = PaymentDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processPaymentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductAll(response: HttpResponseBase): Observable<ProductDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductGET(response: HttpResponseBase): Observable<ProductDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductColorAll(response: HttpResponseBase): Observable<ProductColorDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductColorDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductColorGET(response: HttpResponseBase): Observable<ProductColorDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductColorDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductColorDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductImageAll(response: HttpResponseBase): Observable<ProductImageDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductImageDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImagePOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImagePUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductImageGET(response: HttpResponseBase): Observable<ProductImageDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductImageDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductImageDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductOptionAll(response: HttpResponseBase): Observable<ProductOptionDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductOptionDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductOptionGET(response: HttpResponseBase): Observable<ProductOptionDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductOptionDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductOptionDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductReviewAll(response: HttpResponseBase): Observable<ProductReviewDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductReviewDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductReviewGET(response: HttpResponseBase): Observable<ProductReviewDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductReviewDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductReviewDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductTagAll(response: HttpResponseBase): Observable<ProductTagDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ProductTagDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processProductTagGET(response: HttpResponseBase): Observable<ProductTagDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ProductTagDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processProductTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShipmentAll(response: HttpResponseBase): Observable<ShipmentDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShipmentDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShipmentGET(response: HttpResponseBase): Observable<ShipmentDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ShipmentDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShipmentDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartAll(response: HttpResponseBase): Observable<ShoppingCartDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShoppingCartDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartGET(response: HttpResponseBase): Observable<ShoppingCartDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ShoppingCartDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartItemAll(response: HttpResponseBase): Observable<ShoppingCartItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShoppingCartItemDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processShoppingCartItemGET(response: HttpResponseBase): Observable<ShoppingCartItemDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = ShoppingCartItemDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processShoppingCartItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplierAll(response: HttpResponseBase): Observable<SupplierDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SupplierDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplierGET(response: HttpResponseBase): Observable<SupplierDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = SupplierDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplierDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplyAll(response: HttpResponseBase): Observable<SupplyDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SupplyDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processSupplyGET(response: HttpResponseBase): Observable<SupplyDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = SupplyDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processSupplyDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processTagAll(response: HttpResponseBase): Observable<TagDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TagDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processTagGET(response: HttpResponseBase): Observable<TagDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = TagDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processTagDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUserAll(response: HttpResponseBase): Observable<UserDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(UserDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processUserGET(response: HttpResponseBase): Observable<UserDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = UserDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processUserDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListAll(response: HttpResponseBase): Observable<WishListDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WishListDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListGET(response: HttpResponseBase): Observable<WishListDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = WishListDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListItemAll(response: HttpResponseBase): Observable<WishListItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WishListItemDto.fromJS(item, _mappings));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemPOST(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 201) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400, _mappings);
          return throwException('Bad Request', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }

  protected processWishListItemGET(response: HttpResponseBase): Observable<WishListItemDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result200 = WishListItemDetailsDto.fromJS(resultData200, _mappings);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf(null as any);
  }

  protected processWishListItemDELETE(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404, _mappings);
          return throwException('Not Found', status, _responseText, _headers, result404);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault = _responseText === '' ? null : jsonParse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault, _mappings);
          return throwException('Error', status, _responseText, _headers, resultdefault);
        })
      );
    }
  }
}

export class AddressDetailsDto implements IAddressDetailsDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
  user?: UserDto;

  constructor(data?: IAddressDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): AddressDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<AddressDetailsDto>(data, _mappings, AddressDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAddressDetailsDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
  user?: UserDto;
}

export class AddressDto implements IAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;

  constructor(data?: IAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): AddressDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<AddressDto>(data, _mappings, AddressDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export class ArticleDetailsDto implements IArticleDetailsDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
  authorUser?: UserDto;
  comments?: CommentDto[] | undefined;

  constructor(data?: IArticleDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ArticleDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ArticleDetailsDto>(data, _mappings, ArticleDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
      this.authorUser = _data['authorUser'] ? UserDto.fromJS(_data['authorUser'], _mappings) : <any>undefined;
      if (Array.isArray(_data['comments'])) {
        this.comments = [] as any;
        for (let item of _data['comments']) this.comments!.push(<CommentDto>CommentDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    data['authorUser'] = this.authorUser ? this.authorUser.toJSON() : <any>undefined;
    if (Array.isArray(this.comments)) {
      data['comments'] = [];
      for (let item of this.comments) data['comments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IArticleDetailsDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
  authorUser?: UserDto;
  comments?: CommentDto[] | undefined;
}

export class ArticleDto implements IArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;

  constructor(data?: IArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ArticleDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ArticleDto>(data, _mappings, ArticleDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export class CategoryDetailsDto implements ICategoryDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  products?: ProductDto[] | undefined;

  constructor(data?: ICategoryDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CategoryDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CategoryDetailsDto>(data, _mappings, CategoryDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(<ProductDto>ProductDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products) data['products'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  products?: ProductDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: ICategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CategoryDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CategoryDto>(data, _mappings, CategoryDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface ICategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export class CommentDetailsDto implements ICommentDetailsDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
  article?: ArticleDto;
  user?: UserDto;

  constructor(data?: ICommentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CommentDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CommentDetailsDto>(data, _mappings, CommentDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
      this.article = _data['article'] ? ArticleDto.fromJS(_data['article'], _mappings) : <any>undefined;
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICommentDetailsDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
  article?: ArticleDto;
  user?: UserDto;
}

export class CommentDto implements ICommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;

  constructor(data?: ICommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CommentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CommentDto>(data, _mappings, CommentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export class CreateAddressDto implements ICreateAddressDto {
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;

  constructor(data?: ICreateAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateAddressDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateAddressDto>(data, _mappings, CreateAddressDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateAddressDto {
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number;
}

export class CreateArticleCommand implements ICreateArticleCommand {
  article?: CreateArticleDto;

  constructor(data?: ICreateArticleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateArticleCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateArticleCommand>(data, _mappings, CreateArticleCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.article = _data['article'] ? CreateArticleDto.fromJS(_data['article'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateArticleCommand {
  article?: CreateArticleDto;
}

export class CreateArticleDto implements ICreateArticleDto {
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;

  constructor(data?: ICreateArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateArticleDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateArticleDto>(data, _mappings, CreateArticleDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateArticleDto {
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date;
  userId?: number;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
  category?: CreateCategoryDto;

  constructor(data?: ICreateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateCategoryCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateCategoryCommand>(data, _mappings, CreateCategoryCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.category = _data['category'] ? CreateCategoryDto.fromJS(_data['category'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateCategoryCommand {
  category?: CreateCategoryDto;
}

export class CreateCategoryDto implements ICreateCategoryDto {
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: ICreateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateCategoryDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateCategoryDto>(data, _mappings, CreateCategoryDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface ICreateCategoryDto {
  name?: string | undefined;
  description?: string | undefined;
}

export class CreateCommentCommand implements ICreateCommentCommand {
  comment?: CreateCommentDto;

  constructor(data?: ICreateCommentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateCommentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateCommentCommand>(data, _mappings, CreateCommentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.comment = _data['comment'] ? CreateCommentDto.fromJS(_data['comment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['comment'] = this.comment ? this.comment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateCommentCommand {
  comment?: CreateCommentDto;
}

export class CreateCommentDto implements ICreateCommentDto {
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;

  constructor(data?: ICreateCommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateCommentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateCommentDto>(data, _mappings, CreateCommentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateCommentDto {
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date;
  articleId?: number;
  userId?: number;
}

export class CreateDiscountDto implements ICreateDiscountDto {
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: ICreateDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateDiscountDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateDiscountDto>(data, _mappings, CreateDiscountDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface ICreateDiscountDto {
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class CreateNotificationDto implements ICreateNotificationDto {
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;

  constructor(data?: ICreateNotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateNotificationDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateNotificationDto>(data, _mappings, CreateNotificationDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateNotificationDto {
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export class CreateOrderCommand implements ICreateOrderCommand {
  order?: CreateOrderDto;

  constructor(data?: ICreateOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateOrderCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateOrderCommand>(data, _mappings, CreateOrderCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.order = _data['order'] ? CreateOrderDto.fromJS(_data['order'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateOrderCommand {
  order?: CreateOrderDto;
}

export class CreateOrderDetailCommand implements ICreateOrderDetailCommand {
  orderDetail?: CreateOrderDetailDto;

  constructor(data?: ICreateOrderDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateOrderDetailCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateOrderDetailCommand>(data, _mappings, CreateOrderDetailCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.orderDetail = _data['orderDetail'] ? CreateOrderDetailDto.fromJS(_data['orderDetail'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDetail'] = this.orderDetail ? this.orderDetail.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateOrderDetailCommand {
  orderDetail?: CreateOrderDetailDto;
}

export class CreateOrderDetailDto implements ICreateOrderDetailDto {
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;

  constructor(data?: ICreateOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateOrderDetailDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateOrderDetailDto>(data, _mappings, CreateOrderDetailDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreateOrderDetailDto {
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export class CreateOrderDto implements ICreateOrderDto {
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  orderDetails?: CreateOrderDetailDto[] | undefined;

  constructor(data?: ICreateOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateOrderDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateOrderDto>(data, _mappings, CreateOrderDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(<CreateOrderDetailDto>CreateOrderDetailDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateOrderDto {
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  orderDetails?: CreateOrderDetailDto[] | undefined;
}

export class CreatePaymentCommand implements ICreatePaymentCommand {
  payment?: CreatePaymentDto;

  constructor(data?: ICreatePaymentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreatePaymentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreatePaymentCommand>(data, _mappings, CreatePaymentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.payment = _data['payment'] ? CreatePaymentDto.fromJS(_data['payment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payment'] = this.payment ? this.payment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreatePaymentCommand {
  payment?: CreatePaymentDto;
}

export class CreatePaymentDto implements ICreatePaymentDto {
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;

  constructor(data?: ICreatePaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreatePaymentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreatePaymentDto>(data, _mappings, CreatePaymentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreatePaymentDto {
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export class CreateProductColorDto implements ICreateProductColorDto {
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;

  constructor(data?: ICreateProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductColorDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductColorDto>(data, _mappings, CreateProductColorDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductColorDto {
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export class CreateProductCommand implements ICreateProductCommand {
  product?: CreateProductDto;

  constructor(data?: ICreateProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductCommand>(data, _mappings, CreateProductCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.product = _data['product'] ? CreateProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateProductCommand {
  product?: CreateProductDto;
}

export class CreateProductDto implements ICreateProductDto {
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;

  constructor(data?: ICreateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductDto>(data, _mappings, CreateProductDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface ICreateProductDto {
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export class CreateProductImageDto implements ICreateProductImageDto {
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;

  constructor(data?: ICreateProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductImageDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductImageDto>(data, _mappings, CreateProductImageDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductImageDto {
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export class CreateProductOptionDto implements ICreateProductOptionDto {
  name?: string | undefined;
  value?: number;
  productId?: number;

  constructor(data?: ICreateProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductOptionDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductOptionDto>(data, _mappings, CreateProductOptionDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface ICreateProductOptionDto {
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export class CreateProductReviewCommand implements ICreateProductReviewCommand {
  productReview?: CreateProductReviewDto;

  constructor(data?: ICreateProductReviewCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductReviewCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductReviewCommand>(data, _mappings, CreateProductReviewCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productReview = _data['productReview'] ? CreateProductReviewDto.fromJS(_data['productReview'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productReview'] = this.productReview ? this.productReview.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateProductReviewCommand {
  productReview?: CreateProductReviewDto;
}

export class CreateProductReviewDto implements ICreateProductReviewDto {
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;

  constructor(data?: ICreateProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductReviewDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductReviewDto>(data, _mappings, CreateProductReviewDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateProductReviewDto {
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export class CreateProductTagDto implements ICreateProductTagDto {
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;

  constructor(data?: ICreateProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateProductTagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateProductTagDto>(data, _mappings, CreateProductTagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface ICreateProductTagDto {
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export class CreateShipmentCommand implements ICreateShipmentCommand {
  shipment?: CreateShipmentDto;

  constructor(data?: ICreateShipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShipmentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShipmentCommand>(data, _mappings, CreateShipmentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shipment = _data['shipment'] ? CreateShipmentDto.fromJS(_data['shipment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipment'] = this.shipment ? this.shipment.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShipmentCommand {
  shipment?: CreateShipmentDto;
}

export class CreateShipmentDto implements ICreateShipmentDto {
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;

  constructor(data?: ICreateShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShipmentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShipmentDto>(data, _mappings, CreateShipmentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate'] ? new Date(_data['estimatedDeliveryDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface ICreateShipmentDto {
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export class CreateShoppingCartCommand implements ICreateShoppingCartCommand {
  shoppingCart?: CreateShoppingCartDto;

  constructor(data?: ICreateShoppingCartCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShoppingCartCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShoppingCartCommand>(data, _mappings, CreateShoppingCartCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shoppingCart = _data['shoppingCart'] ? CreateShoppingCartDto.fromJS(_data['shoppingCart'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShoppingCartCommand {
  shoppingCart?: CreateShoppingCartDto;
}

export class CreateShoppingCartDto implements ICreateShoppingCartDto {
  userId?: number;

  constructor(data?: ICreateShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShoppingCartDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShoppingCartDto>(data, _mappings, CreateShoppingCartDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateShoppingCartDto {
  userId?: number;
}

export class CreateShoppingCartItemCommand implements ICreateShoppingCartItemCommand {
  shoppingCartItem?: CreateShoppingCartItemDto;

  constructor(data?: ICreateShoppingCartItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShoppingCartItemCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShoppingCartItemCommand>(data, _mappings, CreateShoppingCartItemCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shoppingCartItem = _data['shoppingCartItem'] ? CreateShoppingCartItemDto.fromJS(_data['shoppingCartItem'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCartItem'] = this.shoppingCartItem ? this.shoppingCartItem.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateShoppingCartItemCommand {
  shoppingCartItem?: CreateShoppingCartItemDto;
}

export class CreateShoppingCartItemDto implements ICreateShoppingCartItemDto {
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;

  constructor(data?: ICreateShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateShoppingCartItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateShoppingCartItemDto>(data, _mappings, CreateShoppingCartItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface ICreateShoppingCartItemDto {
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export class CreateSupplierDto implements ICreateSupplierDto {
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: ICreateSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateSupplierDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateSupplierDto>(data, _mappings, CreateSupplierDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface ICreateSupplierDto {
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class CreateSupplyDto implements ICreateSupplyDto {
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ICreateSupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateSupplyDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateSupplyDto>(data, _mappings, CreateSupplyDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ICreateSupplyDto {
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class CreateTagDto implements ICreateTagDto {
  name?: string | undefined;

  constructor(data?: ICreateTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateTagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateTagDto>(data, _mappings, CreateTagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ICreateTagDto {
  name?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
  user?: CreateUserDto;

  constructor(data?: ICreateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateUserCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateUserCommand>(data, _mappings, CreateUserCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.user = _data['user'] ? CreateUserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateUserCommand {
  user?: CreateUserDto;
}

export class CreateUserDto implements ICreateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateUserDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateUserDto>(data, _mappings, CreateUserDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd'] ? new Date(_data['lockoutEnd'].toString()) : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface ICreateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class CreateWishListCommand implements ICreateWishListCommand {
  wishList?: CreateWishListDto;

  constructor(data?: ICreateWishListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateWishListCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateWishListCommand>(data, _mappings, CreateWishListCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.wishList = _data['wishList'] ? CreateWishListDto.fromJS(_data['wishList'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateWishListCommand {
  wishList?: CreateWishListDto;
}

export class CreateWishListDto implements ICreateWishListDto {
  name?: string | undefined;
  userId?: number;

  constructor(data?: ICreateWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateWishListDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateWishListDto>(data, _mappings, CreateWishListDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface ICreateWishListDto {
  name?: string | undefined;
  userId?: number;
}

export class CreateWishListItemDto implements ICreateWishListItemDto {
  productId?: number;
  wishListId?: number;

  constructor(data?: ICreateWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): CreateWishListItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateWishListItemDto>(data, _mappings, CreateWishListItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface ICreateWishListItemDto {
  productId?: number;
  wishListId?: number;
}

export class DiscountDetailsDto implements IDiscountDetailsDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: IDiscountDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): DiscountDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<DiscountDetailsDto>(data, _mappings, DiscountDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IDiscountDetailsDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class DiscountDto implements IDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;

  constructor(data?: IDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): DiscountDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<DiscountDto>(data, _mappings, DiscountDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number;
  startDate?: Date;
  endDate?: Date;
}

export class LoginModel implements ILoginModel {
  username?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): LoginModel | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<LoginModel>(data, _mappings, LoginModel);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.username = _data['username'];
      this.password = _data['password'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginModel {
  username?: string | undefined;
  password?: string | undefined;
}

export class NotificationDetailsDto implements INotificationDetailsDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  user?: UserDto;

  constructor(data?: INotificationDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): NotificationDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<NotificationDetailsDto>(data, _mappings, NotificationDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface INotificationDetailsDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
  user?: UserDto;
}

export class NotificationDto implements INotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;

  constructor(data?: INotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): NotificationDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<NotificationDto>(data, _mappings, NotificationDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface INotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date;
  isRead?: boolean;
  userId?: number;
}

export class OrderDetailDetailsDto implements IOrderDetailDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  product?: ProductDto;
  order?: OrderDto;

  constructor(data?: IOrderDetailDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrderDetailDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrderDetailDetailsDto>(data, _mappings, OrderDetailDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
      this.order = _data['order'] ? OrderDto.fromJS(_data['order'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IOrderDetailDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
  product?: ProductDto;
  order?: OrderDto;
}

export class OrderDetailDto implements IOrderDetailDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;

  constructor(data?: IOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrderDetailDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrderDetailDto>(data, _mappings, OrderDetailDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IOrderDetailDto {
  id?: number;
  productId?: number;
  quantity?: number;
  unitPrice?: number;
  orderId?: number;
}

export class OrderDetailsDto implements IOrderDetailsDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  user?: UserDto;
  orderDetails?: OrderDetailDto[] | undefined;

  constructor(data?: IOrderDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrderDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrderDetailsDto>(data, _mappings, OrderDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(<OrderDetailDto>OrderDetailDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrderDetailsDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
  user?: UserDto;
  orderDetails?: OrderDetailDto[] | undefined;
}

export class OrderDto implements IOrderDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;

  constructor(data?: IOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrderDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrderDto>(data, _mappings, OrderDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IOrderDto {
  id?: number;
  orderDate?: Date;
  totalPrice?: number;
  orderStatus?: string | undefined;
  userId?: number;
}

export class PaymentDetailsDto implements IPaymentDetailsDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
  order?: OrderDto;

  constructor(data?: IPaymentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PaymentDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<PaymentDetailsDto>(data, _mappings, PaymentDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
      this.order = _data['order'] ? OrderDto.fromJS(_data['order'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPaymentDetailsDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export class PaymentDto implements IPaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;

  constructor(data?: IPaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PaymentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<PaymentDto>(data, _mappings, PaymentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IPaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number;
  paymentDate?: Date;
  orderId?: number;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProblemDetails | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProblemDetails>(data, _mappings, ProblemDetails);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export class ProductColorDetailsDto implements IProductColorDetailsDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductColorDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductColorDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductColorDetailsDto>(data, _mappings, ProductColorDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductColorDetailsDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export class ProductColorDto implements IProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;

  constructor(data?: IProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductColorDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductColorDto>(data, _mappings, ProductColorDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number;
}

export class ProductDetailsDto implements IProductDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
  category?: CategoryDto;
  productOptions?: ProductOptionDto[] | undefined;
  productColors?: ProductColorDto[] | undefined;
  productImages?: ProductImageDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;

  constructor(data?: IProductDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductDetailsDto>(data, _mappings, ProductDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
      this.category = _data['category'] ? CategoryDto.fromJS(_data['category'], _mappings) : <any>undefined;
      if (Array.isArray(_data['productOptions'])) {
        this.productOptions = [] as any;
        for (let item of _data['productOptions']) this.productOptions!.push(<ProductOptionDto>ProductOptionDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['productColors'])) {
        this.productColors = [] as any;
        for (let item of _data['productColors']) this.productColors!.push(<ProductColorDto>ProductColorDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['productImages'])) {
        this.productImages = [] as any;
        for (let item of _data['productImages']) this.productImages!.push(<ProductImageDto>ProductImageDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['productReviews'])) {
        this.productReviews = [] as any;
        for (let item of _data['productReviews']) this.productReviews!.push(<ProductReviewDto>ProductReviewDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    if (Array.isArray(this.productOptions)) {
      data['productOptions'] = [];
      for (let item of this.productOptions) data['productOptions'].push(item.toJSON());
    }
    if (Array.isArray(this.productColors)) {
      data['productColors'] = [];
      for (let item of this.productColors) data['productColors'].push(item.toJSON());
    }
    if (Array.isArray(this.productImages)) {
      data['productImages'] = [];
      for (let item of this.productImages) data['productImages'].push(item.toJSON());
    }
    if (Array.isArray(this.productReviews)) {
      data['productReviews'] = [];
      for (let item of this.productReviews) data['productReviews'].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductDetailsDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
  category?: CategoryDto;
  productOptions?: ProductOptionDto[] | undefined;
  productColors?: ProductColorDto[] | undefined;
  productImages?: ProductImageDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
}

export class ProductDto implements IProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;

  constructor(data?: IProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductDto>(data, _mappings, ProductDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface IProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number;
  categoryId?: number;
}

export class ProductImageDetailsDto implements IProductImageDetailsDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductImageDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductImageDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductImageDetailsDto>(data, _mappings, ProductImageDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductImageDetailsDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
  product?: ProductDto;
}

export class ProductImageDto implements IProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;

  constructor(data?: IProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductImageDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductImageDto>(data, _mappings, ProductImageDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number;
}

export class ProductOptionDetailsDto implements IProductOptionDetailsDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
  product?: ProductDto;

  constructor(data?: IProductOptionDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductOptionDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductOptionDetailsDto>(data, _mappings, ProductOptionDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductOptionDetailsDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
  product?: ProductDto;
}

export class ProductOptionDto implements IProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;

  constructor(data?: IProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductOptionDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductOptionDto>(data, _mappings, ProductOptionDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number;
  productId?: number;
}

export class ProductReviewDetailsDto implements IProductReviewDetailsDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
  product?: ProductDto;
  user?: UserDto;

  constructor(data?: IProductReviewDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductReviewDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductReviewDetailsDto>(data, _mappings, ProductReviewDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductReviewDetailsDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
  product?: ProductDto;
  user?: UserDto;
}

export class ProductReviewDto implements IProductReviewDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;

  constructor(data?: IProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductReviewDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductReviewDto>(data, _mappings, ProductReviewDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IProductReviewDto {
  id?: number;
  rating?: number;
  reviewText?: string | undefined;
  reviewDate?: Date;
  productId?: number;
  userId?: number;
}

export class ProductTagDetailsDto implements IProductTagDetailsDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
  product?: ProductDto;
  tag?: TagDto;

  constructor(data?: IProductTagDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductTagDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductTagDetailsDto>(data, _mappings, ProductTagDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
      this.tag = _data['tag'] ? TagDto.fromJS(_data['tag'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['tag'] = this.tag ? this.tag.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductTagDetailsDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
  product?: ProductDto;
  tag?: TagDto;
}

export class ProductTagDto implements IProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;

  constructor(data?: IProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ProductTagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ProductTagDto>(data, _mappings, ProductTagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface IProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number;
  tagId?: number;
}

export class RegisterModel implements IRegisterModel {
  username?: string | undefined;
  password?: string | undefined;
  passwordHash?: string | undefined;
  passwordSalt?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IRegisterModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): RegisterModel | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<RegisterModel>(data, _mappings, RegisterModel);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.username = _data['username'];
      this.password = _data['password'];
      this.passwordHash = _data['passwordHash'];
      this.passwordSalt = _data['passwordSalt'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    data['passwordHash'] = this.passwordHash;
    data['passwordSalt'] = this.passwordSalt;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface IRegisterModel {
  username?: string | undefined;
  password?: string | undefined;
  passwordHash?: string | undefined;
  passwordSalt?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class RegisterUserCommand implements IRegisterUserCommand {
  registerUser?: RegisterModel;

  constructor(data?: IRegisterUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): RegisterUserCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<RegisterUserCommand>(data, _mappings, RegisterUserCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.registerUser = _data['registerUser'] ? RegisterModel.fromJS(_data['registerUser'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['registerUser'] = this.registerUser ? this.registerUser.toJSON() : <any>undefined;
    return data;
  }
}

export interface IRegisterUserCommand {
  registerUser?: RegisterModel;
}

export class ShipmentDetailsDto implements IShipmentDetailsDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
  order?: OrderDto;

  constructor(data?: IShipmentDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShipmentDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShipmentDetailsDto>(data, _mappings, ShipmentDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate'] ? new Date(_data['estimatedDeliveryDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
      this.order = _data['order'] ? OrderDto.fromJS(_data['order'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShipmentDetailsDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
  order?: OrderDto;
}

export class ShipmentDto implements IShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;

  constructor(data?: IShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShipmentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShipmentDto>(data, _mappings, ShipmentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate'] ? new Date(_data['estimatedDeliveryDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date;
  orderId?: number;
}

export class ShoppingCartDetailsDto implements IShoppingCartDetailsDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
  user?: UserDto;

  constructor(data?: IShoppingCartDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShoppingCartDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShoppingCartDetailsDto>(data, _mappings, ShoppingCartDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['shoppingCartItems'])) {
        this.shoppingCartItems = [] as any;
        for (let item of _data['shoppingCartItems']) this.shoppingCartItems!.push(<ShoppingCartItemDto>ShoppingCartItemDto.fromJS(item, _mappings));
      }
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    if (Array.isArray(this.shoppingCartItems)) {
      data['shoppingCartItems'] = [];
      for (let item of this.shoppingCartItems) data['shoppingCartItems'].push(item.toJSON());
    }
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShoppingCartDetailsDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
  user?: UserDto;
}

export class ShoppingCartDto implements IShoppingCartDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;

  constructor(data?: IShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShoppingCartDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShoppingCartDto>(data, _mappings, ShoppingCartDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['shoppingCartItems'])) {
        this.shoppingCartItems = [] as any;
        for (let item of _data['shoppingCartItems']) this.shoppingCartItems!.push(<ShoppingCartItemDto>ShoppingCartItemDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    if (Array.isArray(this.shoppingCartItems)) {
      data['shoppingCartItems'] = [];
      for (let item of this.shoppingCartItems) data['shoppingCartItems'].push(item.toJSON());
    }
    return data;
  }
}

export interface IShoppingCartDto {
  id?: number;
  userId?: number;
  shoppingCartItems?: ShoppingCartItemDto[] | undefined;
}

export class ShoppingCartItemDetailsDto implements IShoppingCartItemDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
  product?: ProductDto;
  shoppingCart?: ShoppingCartDto;

  constructor(data?: IShoppingCartItemDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShoppingCartItemDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShoppingCartItemDetailsDto>(data, _mappings, ShoppingCartItemDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
      this.shoppingCart = _data['shoppingCart'] ? ShoppingCartDto.fromJS(_data['shoppingCart'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface IShoppingCartItemDetailsDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
  product?: ProductDto;
  shoppingCart?: ShoppingCartDto;
}

export class ShoppingCartItemDto implements IShoppingCartItemDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;

  constructor(data?: IShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): ShoppingCartItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<ShoppingCartItemDto>(data, _mappings, ShoppingCartItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface IShoppingCartItemDto {
  id?: number;
  productId?: number;
  quantity?: number;
  price?: number;
  shoppingCartId?: number;
}

export class SupplierDetailsDto implements ISupplierDetailsDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  products?: ProductDto[] | undefined;

  constructor(data?: ISupplierDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): SupplierDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<SupplierDetailsDto>(data, _mappings, SupplierDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(<ProductDto>ProductDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products) data['products'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplierDetailsDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  products?: ProductDto[] | undefined;
}

export class SupplierDto implements ISupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: ISupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): SupplierDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<SupplierDto>(data, _mappings, SupplierDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface ISupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class SupplyDetailsDto implements ISupplyDetailsDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ISupplyDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): SupplyDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<SupplyDetailsDto>(data, _mappings, SupplyDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ISupplyDetailsDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class SupplyDto implements ISupplyDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;

  constructor(data?: ISupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): SupplyDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<SupplyDto>(data, _mappings, SupplyDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface ISupplyDto {
  id?: number;
  productId?: number;
  supplierId?: number;
  quantity?: number;
  price?: number;
}

export class TagDetailsDto implements ITagDetailsDto {
  id?: number;
  name?: string | undefined;
  productTags?: ProductTagDto[] | undefined;
  articles?: ArticleDto[] | undefined;

  constructor(data?: ITagDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): TagDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<TagDetailsDto>(data, _mappings, TagDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['productTags'])) {
        this.productTags = [] as any;
        for (let item of _data['productTags']) this.productTags!.push(<ProductTagDto>ProductTagDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['articles'])) {
        this.articles = [] as any;
        for (let item of _data['articles']) this.articles!.push(<ArticleDto>ArticleDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.productTags)) {
      data['productTags'] = [];
      for (let item of this.productTags) data['productTags'].push(item.toJSON());
    }
    if (Array.isArray(this.articles)) {
      data['articles'] = [];
      for (let item of this.articles) data['articles'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITagDetailsDto {
  id?: number;
  name?: string | undefined;
  productTags?: ProductTagDto[] | undefined;
  articles?: ArticleDto[] | undefined;
}

export class TagDto implements ITagDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: ITagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): TagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<TagDto>(data, _mappings, TagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ITagDto {
  id?: number;
  name?: string | undefined;
}

export class UpdateAddressDto implements IUpdateAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateAddressDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateAddressDto>(data, _mappings, UpdateAddressDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.street = _data['street'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.postalCode = _data['postalCode'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['street'] = this.street;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['postalCode'] = this.postalCode;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateAddressDto {
  id?: number;
  street?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
  userId?: number | undefined;
}

export class UpdateArticleCommand implements IUpdateArticleCommand {
  article?: UpdateArticleDto;

  constructor(data?: IUpdateArticleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateArticleCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateArticleCommand>(data, _mappings, UpdateArticleCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.article = _data['article'] ? UpdateArticleDto.fromJS(_data['article'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['article'] = this.article ? this.article.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateArticleCommand {
  article?: UpdateArticleDto;
}

export class UpdateArticleDto implements IUpdateArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateArticleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateArticleDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateArticleDto>(data, _mappings, UpdateArticleDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.publicationDate = _data['publicationDate'] ? new Date(_data['publicationDate'].toString()) : <any>undefined;
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['author'] = this.author;
    data['publicationDate'] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateArticleDto {
  id?: number;
  title?: string | undefined;
  content?: string | undefined;
  author?: string | undefined;
  publicationDate?: Date | undefined;
  userId?: number | undefined;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
  category?: UpdateCategoryDto;

  constructor(data?: IUpdateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateCategoryCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateCategoryCommand>(data, _mappings, UpdateCategoryCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.category = _data['category'] ? UpdateCategoryDto.fromJS(_data['category'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateCategoryCommand {
  category?: UpdateCategoryDto;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: IUpdateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateCategoryDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateCategoryDto>(data, _mappings, UpdateCategoryDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface IUpdateCategoryDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export class UpdateCommentCommand implements IUpdateCommentCommand {
  comment?: UpdateCommentDto;

  constructor(data?: IUpdateCommentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateCommentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateCommentCommand>(data, _mappings, UpdateCommentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.comment = _data['comment'] ? UpdateCommentDto.fromJS(_data['comment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['comment'] = this.comment ? this.comment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateCommentCommand {
  comment?: UpdateCommentDto;
}

export class UpdateCommentDto implements IUpdateCommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date | undefined;
  articleId?: number | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateCommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateCommentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateCommentDto>(data, _mappings, UpdateCommentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.author = _data['author'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.articleId = _data['articleId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['author'] = this.author;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['articleId'] = this.articleId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateCommentDto {
  id?: number;
  content?: string | undefined;
  author?: string | undefined;
  timestamp?: Date | undefined;
  articleId?: number | undefined;
  userId?: number | undefined;
}

export class UpdateDiscountDto implements IUpdateDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;

  constructor(data?: IUpdateDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateDiscountDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateDiscountDto>(data, _mappings, UpdateDiscountDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.percentage = _data['percentage'];
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['percentage'] = this.percentage;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateDiscountDto {
  id?: number;
  code?: string | undefined;
  percentage?: number | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
}

export class UpdateNotificationDto implements IUpdateNotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date | undefined;
  isRead?: boolean | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateNotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateNotificationDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateNotificationDto>(data, _mappings, UpdateNotificationDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.message = _data['message'];
      this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
      this.isRead = _data['isRead'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['message'] = this.message;
    data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateNotificationDto {
  id?: number;
  message?: string | undefined;
  timestamp?: Date | undefined;
  isRead?: boolean | undefined;
  userId?: number | undefined;
}

export class UpdateOrderCommand implements IUpdateOrderCommand {
  order?: UpdateOrderDto;

  constructor(data?: IUpdateOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateOrderCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateOrderCommand>(data, _mappings, UpdateOrderCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.order = _data['order'] ? UpdateOrderDto.fromJS(_data['order'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateOrderCommand {
  order?: UpdateOrderDto;
}

export class UpdateOrderDetailCommand implements IUpdateOrderDetailCommand {
  orderDetail?: UpdateOrderDetailDto;

  constructor(data?: IUpdateOrderDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateOrderDetailCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateOrderDetailCommand>(data, _mappings, UpdateOrderDetailCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.orderDetail = _data['orderDetail'] ? UpdateOrderDetailDto.fromJS(_data['orderDetail'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderDetail'] = this.orderDetail ? this.orderDetail.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateOrderDetailCommand {
  orderDetail?: UpdateOrderDetailDto;
}

export class UpdateOrderDetailDto implements IUpdateOrderDetailDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdateOrderDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateOrderDetailDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateOrderDetailDto>(data, _mappings, UpdateOrderDetailDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdateOrderDetailDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  orderId?: number | undefined;
}

export class UpdateOrderDto implements IUpdateOrderDto {
  id?: number;
  orderDate?: Date | undefined;
  totalPrice?: number | undefined;
  orderStatus?: string | undefined;
  userId?: number | undefined;
  orderDetails?: UpdateOrderDetailDto[] | undefined;

  constructor(data?: IUpdateOrderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateOrderDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateOrderDto>(data, _mappings, UpdateOrderDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.orderDate = _data['orderDate'] ? new Date(_data['orderDate'].toString()) : <any>undefined;
      this.totalPrice = _data['totalPrice'];
      this.orderStatus = _data['orderStatus'];
      this.userId = _data['userId'];
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails']) this.orderDetails!.push(<UpdateOrderDetailDto>UpdateOrderDetailDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
    data['totalPrice'] = this.totalPrice;
    data['orderStatus'] = this.orderStatus;
    data['userId'] = this.userId;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails) data['orderDetails'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateOrderDto {
  id?: number;
  orderDate?: Date | undefined;
  totalPrice?: number | undefined;
  orderStatus?: string | undefined;
  userId?: number | undefined;
  orderDetails?: UpdateOrderDetailDto[] | undefined;
}

export class UpdatePaymentCommand implements IUpdatePaymentCommand {
  payment?: UpdatePaymentDto;

  constructor(data?: IUpdatePaymentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdatePaymentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdatePaymentCommand>(data, _mappings, UpdatePaymentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.payment = _data['payment'] ? UpdatePaymentDto.fromJS(_data['payment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payment'] = this.payment ? this.payment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdatePaymentCommand {
  payment?: UpdatePaymentDto;
}

export class UpdatePaymentDto implements IUpdatePaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number | undefined;
  paymentDate?: Date | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdatePaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdatePaymentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdatePaymentDto>(data, _mappings, UpdatePaymentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.paymentMethod = _data['paymentMethod'];
      this.amountPaid = _data['amountPaid'];
      this.paymentDate = _data['paymentDate'] ? new Date(_data['paymentDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['paymentMethod'] = this.paymentMethod;
    data['amountPaid'] = this.amountPaid;
    data['paymentDate'] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdatePaymentDto {
  id?: number;
  paymentMethod?: string | undefined;
  amountPaid?: number | undefined;
  paymentDate?: Date | undefined;
  orderId?: number | undefined;
}

export class UpdateProductColorDto implements IUpdateProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductColorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductColorDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductColorDto>(data, _mappings, UpdateProductColorDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.colorName = _data['colorName'];
      this.colorHexCode = _data['colorHexCode'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['colorName'] = this.colorName;
    data['colorHexCode'] = this.colorHexCode;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductColorDto {
  id?: number;
  colorName?: string | undefined;
  colorHexCode?: string | undefined;
  productId?: number | undefined;
}

export class UpdateProductCommand implements IUpdateProductCommand {
  product?: UpdateProductDto;

  constructor(data?: IUpdateProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductCommand>(data, _mappings, UpdateProductCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.product = _data['product'] ? UpdateProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateProductCommand {
  product?: UpdateProductDto;
}

export class UpdateProductDto implements IUpdateProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number | undefined;
  categoryId?: number | undefined;

  constructor(data?: IUpdateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductDto>(data, _mappings, UpdateProductDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.categoryId = _data['categoryId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['categoryId'] = this.categoryId;
    return data;
  }
}

export interface IUpdateProductDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  price?: number | undefined;
  categoryId?: number | undefined;
}

export class UpdateProductImageDto implements IUpdateProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductImageDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductImageDto>(data, _mappings, UpdateProductImageDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.imageUrl = _data['imageUrl'];
      this.imageDescription = _data['imageDescription'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['imageUrl'] = this.imageUrl;
    data['imageDescription'] = this.imageDescription;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductImageDto {
  id?: number;
  imageUrl?: string | undefined;
  imageDescription?: string | undefined;
  productId?: number | undefined;
}

export class UpdateProductOptionDto implements IUpdateProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number | undefined;
  productId?: number | undefined;

  constructor(data?: IUpdateProductOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductOptionDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductOptionDto>(data, _mappings, UpdateProductOptionDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.productId = _data['productId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['productId'] = this.productId;
    return data;
  }
}

export interface IUpdateProductOptionDto {
  id?: number;
  name?: string | undefined;
  value?: number | undefined;
  productId?: number | undefined;
}

export class UpdateProductReviewCommand implements IUpdateProductReviewCommand {
  productReview?: UpdateProductReviewDto;

  constructor(data?: IUpdateProductReviewCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductReviewCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductReviewCommand>(data, _mappings, UpdateProductReviewCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.productReview = _data['productReview'] ? UpdateProductReviewDto.fromJS(_data['productReview'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productReview'] = this.productReview ? this.productReview.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateProductReviewCommand {
  productReview?: UpdateProductReviewDto;
}

export class UpdateProductReviewDto implements IUpdateProductReviewDto {
  id?: number;
  rating?: number | undefined;
  reviewText?: string | undefined;
  reviewDate?: Date | undefined;
  productId?: number | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateProductReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductReviewDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductReviewDto>(data, _mappings, UpdateProductReviewDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.rating = _data['rating'];
      this.reviewText = _data['reviewText'];
      this.reviewDate = _data['reviewDate'] ? new Date(_data['reviewDate'].toString()) : <any>undefined;
      this.productId = _data['productId'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['rating'] = this.rating;
    data['reviewText'] = this.reviewText;
    data['reviewDate'] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateProductReviewDto {
  id?: number;
  rating?: number | undefined;
  reviewText?: string | undefined;
  reviewDate?: Date | undefined;
  productId?: number | undefined;
  userId?: number | undefined;
}

export class UpdateProductTagDto implements IUpdateProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number | undefined;
  tagId?: number | undefined;

  constructor(data?: IUpdateProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateProductTagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateProductTagDto>(data, _mappings, UpdateProductTagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tagName = _data['tagName'];
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tagName'] = this.tagName;
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface IUpdateProductTagDto {
  id?: number;
  tagName?: string | undefined;
  productId?: number | undefined;
  tagId?: number | undefined;
}

export class UpdateShipmentCommand implements IUpdateShipmentCommand {
  shipment?: UpdateShipmentDto;

  constructor(data?: IUpdateShipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShipmentCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShipmentCommand>(data, _mappings, UpdateShipmentCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shipment = _data['shipment'] ? UpdateShipmentDto.fromJS(_data['shipment'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipment'] = this.shipment ? this.shipment.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShipmentCommand {
  shipment?: UpdateShipmentDto;
}

export class UpdateShipmentDto implements IUpdateShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  orderId?: number | undefined;

  constructor(data?: IUpdateShipmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShipmentDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShipmentDto>(data, _mappings, UpdateShipmentDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.shippingMethod = _data['shippingMethod'];
      this.trackingNumber = _data['trackingNumber'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate'] ? new Date(_data['estimatedDeliveryDate'].toString()) : <any>undefined;
      this.orderId = _data['orderId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['shippingMethod'] = this.shippingMethod;
    data['trackingNumber'] = this.trackingNumber;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : <any>undefined;
    data['orderId'] = this.orderId;
    return data;
  }
}

export interface IUpdateShipmentDto {
  id?: number;
  shippingMethod?: string | undefined;
  trackingNumber?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  orderId?: number | undefined;
}

export class UpdateShoppingCartCommand implements IUpdateShoppingCartCommand {
  shoppingCart?: UpdateShoppingCartDto;

  constructor(data?: IUpdateShoppingCartCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShoppingCartCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShoppingCartCommand>(data, _mappings, UpdateShoppingCartCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shoppingCart = _data['shoppingCart'] ? UpdateShoppingCartDto.fromJS(_data['shoppingCart'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShoppingCartCommand {
  shoppingCart?: UpdateShoppingCartDto;
}

export class UpdateShoppingCartDto implements IUpdateShoppingCartDto {
  id?: number;
  userId?: number | undefined;

  constructor(data?: IUpdateShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShoppingCartDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShoppingCartDto>(data, _mappings, UpdateShoppingCartDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateShoppingCartDto {
  id?: number;
  userId?: number | undefined;
}

export class UpdateShoppingCartItemCommand implements IUpdateShoppingCartItemCommand {
  shoppingCartItem?: UpdateShoppingCartItemDto;

  constructor(data?: IUpdateShoppingCartItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShoppingCartItemCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShoppingCartItemCommand>(data, _mappings, UpdateShoppingCartItemCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.shoppingCartItem = _data['shoppingCartItem'] ? UpdateShoppingCartItemDto.fromJS(_data['shoppingCartItem'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shoppingCartItem'] = this.shoppingCartItem ? this.shoppingCartItem.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateShoppingCartItemCommand {
  shoppingCartItem?: UpdateShoppingCartItemDto;
}

export class UpdateShoppingCartItemDto implements IUpdateShoppingCartItemDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  shoppingCartId?: number | undefined;

  constructor(data?: IUpdateShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateShoppingCartItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateShoppingCartItemDto>(data, _mappings, UpdateShoppingCartItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
      this.shoppingCartId = _data['shoppingCartId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    data['shoppingCartId'] = this.shoppingCartId;
    return data;
  }
}

export interface IUpdateShoppingCartItemDto {
  id?: number;
  productId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  shoppingCartId?: number | undefined;
}

export class UpdateSupplierDto implements IUpdateSupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;

  constructor(data?: IUpdateSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateSupplierDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateSupplierDto>(data, _mappings, UpdateSupplierDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    return data;
  }
}

export interface IUpdateSupplierDto {
  id?: number;
  name?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
}

export class UpdateSupplyDto implements IUpdateSupplyDto {
  id?: number;
  productId?: number | undefined;
  supplierId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;

  constructor(data?: IUpdateSupplyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateSupplyDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateSupplyDto>(data, _mappings, UpdateSupplyDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.supplierId = _data['supplierId'];
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['supplierId'] = this.supplierId;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface IUpdateSupplyDto {
  id?: number;
  productId?: number | undefined;
  supplierId?: number | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
}

export class UpdateTagDto implements IUpdateTagDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: IUpdateTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateTagDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateTagDto>(data, _mappings, UpdateTagDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IUpdateTagDto {
  id?: number;
  name?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
  user?: UpdateUserDto;

  constructor(data?: IUpdateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateUserCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateUserCommand>(data, _mappings, UpdateUserCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.user = _data['user'] ? UpdateUserDto.fromJS(_data['user'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateUserCommand {
  user?: UpdateUserDto;
}

export class UpdateUserDto implements IUpdateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IUpdateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateUserDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateUserDto>(data, _mappings, UpdateUserDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd'] ? new Date(_data['lockoutEnd'].toString()) : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface IUpdateUserDto {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class UpdateWishListCommand implements IUpdateWishListCommand {
  wishList?: UpdateWishListDto;

  constructor(data?: IUpdateWishListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateWishListCommand | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateWishListCommand>(data, _mappings, UpdateWishListCommand);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.wishList = _data['wishList'] ? UpdateWishListDto.fromJS(_data['wishList'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateWishListCommand {
  wishList?: UpdateWishListDto;
}

export class UpdateWishListDto implements IUpdateWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number | undefined;

  constructor(data?: IUpdateWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateWishListDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateWishListDto>(data, _mappings, UpdateWishListDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUpdateWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number | undefined;
}

export class UpdateWishListItemDto implements IUpdateWishListItemDto {
  id?: number;
  productId?: number | undefined;
  wishListId?: number | undefined;

  constructor(data?: IUpdateWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateWishListItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateWishListItemDto>(data, _mappings, UpdateWishListItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface IUpdateWishListItemDto {
  id?: number;
  productId?: number | undefined;
  wishListId?: number | undefined;
}

export class UserDetailsDto implements IUserDetailsDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  token?: string | undefined;
  orders?: OrderDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
  wishLists?: WishListDto[] | undefined;
  comments?: CommentDto[] | undefined;
  notifications?: NotificationDto[] | undefined;

  constructor(data?: IUserDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UserDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserDetailsDto>(data, _mappings, UserDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
      this.token = _data['token'];
      if (Array.isArray(_data['orders'])) {
        this.orders = [] as any;
        for (let item of _data['orders']) this.orders!.push(<OrderDto>OrderDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['productReviews'])) {
        this.productReviews = [] as any;
        for (let item of _data['productReviews']) this.productReviews!.push(<ProductReviewDto>ProductReviewDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['wishLists'])) {
        this.wishLists = [] as any;
        for (let item of _data['wishLists']) this.wishLists!.push(<WishListDto>WishListDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['comments'])) {
        this.comments = [] as any;
        for (let item of _data['comments']) this.comments!.push(<CommentDto>CommentDto.fromJS(item, _mappings));
      }
      if (Array.isArray(_data['notifications'])) {
        this.notifications = [] as any;
        for (let item of _data['notifications']) this.notifications!.push(<NotificationDto>NotificationDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    data['token'] = this.token;
    if (Array.isArray(this.orders)) {
      data['orders'] = [];
      for (let item of this.orders) data['orders'].push(item.toJSON());
    }
    if (Array.isArray(this.productReviews)) {
      data['productReviews'] = [];
      for (let item of this.productReviews) data['productReviews'].push(item.toJSON());
    }
    if (Array.isArray(this.wishLists)) {
      data['wishLists'] = [];
      for (let item of this.wishLists) data['wishLists'].push(item.toJSON());
    }
    if (Array.isArray(this.comments)) {
      data['comments'] = [];
      for (let item of this.comments) data['comments'].push(item.toJSON());
    }
    if (Array.isArray(this.notifications)) {
      data['notifications'] = [];
      for (let item of this.notifications) data['notifications'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserDetailsDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  token?: string | undefined;
  orders?: OrderDto[] | undefined;
  productReviews?: ProductReviewDto[] | undefined;
  wishLists?: WishListDto[] | undefined;
  comments?: CommentDto[] | undefined;
  notifications?: NotificationDto[] | undefined;
}

export class UserDto implements IUserDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UserDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserDto>(data, _mappings, UserDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phone = _data['phone'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phone'] = this.phone;
    return data;
  }
}

export interface IUserDto {
  id?: number;
  userName?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
}

export class WishListDetailsDto implements IWishListDetailsDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
  user?: UserDto;
  wishListItems?: WishListItemDto[] | undefined;

  constructor(data?: IWishListDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): WishListDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<WishListDetailsDto>(data, _mappings, WishListDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
      this.user = _data['user'] ? UserDto.fromJS(_data['user'], _mappings) : <any>undefined;
      if (Array.isArray(_data['wishListItems'])) {
        this.wishListItems = [] as any;
        for (let item of _data['wishListItems']) this.wishListItems!.push(<WishListItemDto>WishListItemDto.fromJS(item, _mappings));
      }
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.wishListItems)) {
      data['wishListItems'] = [];
      for (let item of this.wishListItems) data['wishListItems'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWishListDetailsDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
  user?: UserDto;
  wishListItems?: WishListItemDto[] | undefined;
}

export class WishListDto implements IWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number;

  constructor(data?: IWishListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): WishListDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<WishListDto>(data, _mappings, WishListDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IWishListDto {
  id?: number;
  name?: string | undefined;
  userId?: number;
}

export class WishListItemDetailsDto implements IWishListItemDetailsDto {
  id?: number;
  productId?: number;
  wishListId?: number;
  product?: ProductDto;
  wishList?: WishListDto;

  constructor(data?: IWishListItemDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): WishListItemDetailsDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<WishListItemDetailsDto>(data, _mappings, WishListItemDetailsDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
      this.product = _data['product'] ? ProductDto.fromJS(_data['product'], _mappings) : <any>undefined;
      this.wishList = _data['wishList'] ? WishListDto.fromJS(_data['wishList'], _mappings) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    data['product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['wishList'] = this.wishList ? this.wishList.toJSON() : <any>undefined;
    return data;
  }
}

export interface IWishListItemDetailsDto {
  id?: number;
  productId?: number;
  wishListId?: number;
  product?: ProductDto;
  wishList?: WishListDto;
}

export class WishListItemDto implements IWishListItemDto {
  id?: number;
  productId?: number;
  wishListId?: number;

  constructor(data?: IWishListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any, _mappings?: any): WishListItemDto | null {
    data = typeof data === 'object' ? data : {};
    return createInstance<WishListItemDto>(data, _mappings, WishListItemDto);
  }

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.productId = _data['productId'];
      this.wishListId = _data['wishListId'];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['productId'] = this.productId;
    data['wishListId'] = this.wishListId;
    return data;
  }
}

export interface IWishListItemDto {
  id?: number;
  productId?: number;
  wishListId?: number;
}

function jsonParse(json: any, reviver?: any) {
  json = JSON.parse(json, reviver);

  var byid: any = {};
  var refs: any = [];
  json = (function recurse(obj: any, prop?: any, parent?: any) {
    if (typeof obj !== 'object' || !obj) return obj;

    if ('$ref' in obj) {
      let ref = obj.$ref;
      if (ref in byid) return byid[ref];
      refs.push([parent, prop, ref]);
      return undefined;
    } else if ('$id' in obj) {
      let id = obj.$id;
      delete obj.$id;
      if ('$values' in obj) obj = obj.$values;
      byid[id] = obj;
    }

    if (Array.isArray(obj)) {
      obj = obj.map((v, i) => recurse(v, i, obj));
    } else {
      for (var p in obj) {
        if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object') obj[p] = recurse(obj[p], p, obj);
      }
    }

    return obj;
  })(json);

  for (let i = 0; i < refs.length; i++) {
    const ref = refs[i];
    ref[0][ref[1]] = byid[ref[2]];
  }

  return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings) mappings = [];
  if (!data) return null;

  const mappingIndexName = '__mappingIndex';
  if (data[mappingIndexName]) return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;
  protected isApiException = true;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: {
    [key: string]: any;
  },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
